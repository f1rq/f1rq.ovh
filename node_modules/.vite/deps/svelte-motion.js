import "./chunk-RIXFT5AQ.js";
import "./chunk-RP4Z6QEY.js";
import "./chunk-PN7HLM2Q.js";
import {
  action,
  add_locations,
  afterUpdate,
  assign,
  beforeUpdate,
  check_target,
  component,
  derived,
  each,
  element,
  get as get2,
  hmr,
  if_block,
  init,
  legacy_api,
  legacy_rest_props,
  onDestroy,
  onMount,
  prop,
  readable,
  set_attributes,
  setup_stores,
  slot,
  spread_props,
  store_get,
  validate_dynamic_element_tag,
  validate_each_keys,
  validate_store,
  validate_void_dynamic_element,
  wrap_snippet,
  writable
} from "./chunk-MLA7ENGX.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  template
} from "./chunk-2NU4JMK7.js";
import {
  FILENAME,
  HMR,
  child,
  deep_read_state,
  derived_safe_equal,
  first_child,
  get,
  getContext,
  invalid_default_snippet,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mark_module_end,
  mark_module_start,
  mutable_source,
  mutate,
  pop,
  push,
  reset,
  set,
  setContext,
  sibling,
  strict_equals,
  template_effect,
  tick
} from "./chunk-KTFBT3RB.js";
import "./chunk-X4XZK27Q.js";
import "./chunk-2DGCMXEA.js";
import "./chunk-RVAV4ZRS.js";
import {
  __require
} from "./chunk-4VWCUJXE.js";

// node_modules/svelte-motion/src/components/AnimateSharedLayout/types.js
var Presence;
(function(Presence2) {
  Presence2[Presence2["Entering"] = 0] = "Entering";
  Presence2[Presence2["Present"] = 1] = "Present";
  Presence2[Presence2["Exiting"] = 2] = "Exiting";
})(Presence || (Presence = {}));
var VisibilityAction2;
(function(VisibilityAction3) {
  VisibilityAction3[VisibilityAction3["Hide"] = 0] = "Hide";
  VisibilityAction3[VisibilityAction3["Show"] = 1] = "Show";
})(VisibilityAction2 || (VisibilityAction2 = {}));

// node_modules/svelte-motion/src/utils/fix-process-env.js
var fix = () => {
  try {
    if (!process.env) {
      process.env = {};
    }
    return true;
    ;
  } catch (e) {
  }
  if (!window || window.process && window.process.env) {
    return false;
  }
  if (!window.process) {
    window.process = {};
  }
  window.process.env = {};
  return true;
};
var fixed = fix();

// node_modules/svelte-motion/src/value/index.js
import sync, { getFrameData } from "framesync";
import { velocityPerSecond } from "popmotion";

// node_modules/svelte-motion/src/utils/array.js
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  var index = arr.indexOf(item);
  index > -1 && arr.splice(index, 1);
}

// node_modules/svelte-motion/src/utils/subscription-manager.js
var SubscriptionManager = (
  /** @class */
  function() {
    function SubscriptionManager2() {
      this.subscriptions = [];
    }
    SubscriptionManager2.prototype.add = function(handler) {
      var _this = this;
      addUniqueItem(this.subscriptions, handler);
      return function() {
        return removeItem(_this.subscriptions, handler);
      };
    };
    SubscriptionManager2.prototype.notify = function(a, b, c) {
      var numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a, b, c);
      } else {
        for (var i = 0; i < numSubscriptions; i++) {
          var handler = this.subscriptions[i];
          handler && handler(a, b, c);
        }
      }
    };
    SubscriptionManager2.prototype.getSize = function() {
      return this.subscriptions.length;
    };
    SubscriptionManager2.prototype.clear = function() {
      this.subscriptions.length = 0;
    };
    return SubscriptionManager2;
  }()
);

// node_modules/svelte-motion/src/value/index.js
var isFloat = function(value) {
  return !isNaN(parseFloat(value));
};
var MotionValue = (
  /** @class */
  function() {
    function MotionValue2(init2, startStopNotifier) {
      var _this = this;
      this.timeDelta = 0;
      this.lastUpdated = 0;
      this.updateSubscribers = new SubscriptionManager();
      this.velocityUpdateSubscribers = new SubscriptionManager();
      this.renderSubscribers = new SubscriptionManager();
      this.canTrackVelocity = false;
      this.updateAndNotify = function(v, render) {
        if (render === void 0) {
          render = true;
        }
        _this.prev = _this.current;
        _this.current = v;
        var _a = getFrameData(), delta2 = _a.delta, timestamp = _a.timestamp;
        if (_this.lastUpdated !== timestamp) {
          _this.timeDelta = delta2;
          _this.lastUpdated = timestamp;
          sync.postRender(_this.scheduleVelocityCheck);
        }
        if (_this.prev !== _this.current) {
          _this.updateSubscribers.notify(_this.current);
        }
        if (_this.velocityUpdateSubscribers.getSize()) {
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
        if (render) {
          _this.renderSubscribers.notify(_this.current);
        }
      };
      this.scheduleVelocityCheck = function() {
        return sync.postRender(_this.velocityCheck);
      };
      this.velocityCheck = function(_a) {
        var timestamp = _a.timestamp;
        if (timestamp !== _this.lastUpdated) {
          _this.prev = _this.current;
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
      };
      this.hasAnimated = false;
      this.prev = this.current = init2;
      this.canTrackVelocity = isFloat(this.current);
      this.onSubscription = () => {
      };
      this.onUnsubscription = () => {
      };
      if (startStopNotifier) {
        this.onSubscription = () => {
          if (this.updateSubscribers.getSize() + this.velocityUpdateSubscribers.getSize() + this.renderSubscribers.getSize() === 0) {
            const unsub = startStopNotifier();
            this.onUnsubscription = () => {
            };
            if (unsub) {
              this.onUnsubscription = () => {
                if (this.updateSubscribers.getSize() + this.velocityUpdateSubscribers.getSize() + this.renderSubscribers.getSize() === 0) {
                  unsub();
                }
              };
            }
          }
        };
      }
    }
    MotionValue2.prototype.onChange = function(subscription) {
      this.onSubscription();
      const unsub = this.updateSubscribers.add(subscription);
      return () => {
        unsub();
        this.onUnsubscription();
      };
    };
    MotionValue2.prototype.subscribe = function(subscription) {
      return this.onChange(subscription);
    };
    MotionValue2.prototype.clearListeners = function() {
      this.updateSubscribers.clear();
      this.onUnsubscription();
    };
    MotionValue2.prototype.onRenderRequest = function(subscription) {
      this.onSubscription();
      subscription(this.get());
      const unsub = this.renderSubscribers.add(subscription);
      return () => {
        unsub();
        this.onUnsubscription();
      };
    };
    MotionValue2.prototype.attach = function(passiveEffect) {
      this.passiveEffect = passiveEffect;
    };
    MotionValue2.prototype.set = function(v, render) {
      if (render === void 0) {
        render = true;
      }
      if (!render || !this.passiveEffect) {
        this.updateAndNotify(v, render);
      } else {
        this.passiveEffect(v, this.updateAndNotify);
      }
    };
    MotionValue2.prototype.update = function(v) {
      this.set(v(this.get()));
    };
    MotionValue2.prototype.get = function() {
      this.onSubscription();
      const curr = this.current;
      this.onUnsubscription();
      return curr;
    };
    MotionValue2.prototype.getPrevious = function() {
      return this.prev;
    };
    MotionValue2.prototype.getVelocity = function() {
      this.onSubscription();
      const vel = this.canTrackVelocity ? (
        // These casts could be avoided if parseFloat would be typed better
        velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      ) : 0;
      this.onUnsubscription();
      return vel;
    };
    MotionValue2.prototype.start = function(animation) {
      var _this = this;
      this.stop();
      return new Promise(function(resolve) {
        _this.hasAnimated = true;
        _this.stopAnimation = animation(resolve);
      }).then(function() {
        return _this.clearAnimation();
      });
    };
    MotionValue2.prototype.stop = function() {
      if (this.stopAnimation)
        this.stopAnimation();
      this.clearAnimation();
    };
    MotionValue2.prototype.isAnimating = function() {
      return !!this.stopAnimation;
    };
    MotionValue2.prototype.clearAnimation = function() {
      this.stopAnimation = null;
    };
    MotionValue2.prototype.destroy = function() {
      this.updateSubscribers.clear();
      this.renderSubscribers.clear();
      this.stop();
      this.onUnsubscription();
    };
    return MotionValue2;
  }()
);
function motionValue(init2, startStopNotifier) {
  return new MotionValue(init2, startStopNotifier);
}

// node_modules/svelte-motion/src/context/DOMcontext.js
var getDomContext = (name, el) => {
  if (!el || !window) {
    return void 0;
  }
  let par = el;
  while (par = par.parentNode) {
    if (par.motionDomContext && par.motionDomContext.has(name)) {
      return par.motionDomContext.get(name);
    }
  }
  return void 0;
};
var setDomContext = (name, el, value) => {
  if (el && window) {
    if (!el.motionDomContext) {
      el.motionDomContext = /* @__PURE__ */ new Map();
    }
    el.motionDomContext.set(name, value);
  }
};

// node_modules/svelte-motion/src/context/MotionConfigContext.js
var MotionConfigContext = (c) => getDomContext("MotionConfig", c) || writable({
  transformPagePoint: function(p) {
    return p;
  },
  isStatic: false
});

// node_modules/svelte-motion/src/context/ScaleCorrectionProvider.svelte
mark_module_start();
ScaleCorrectionProvider[FILENAME] = "node_modules/svelte-motion/src/context/ScaleCorrectionProvider.svelte";
var ScaleCorrectionContext = (isCustom) => getDomContext("ScaleCorrection", isCustom) || writable([]);
var ScaleCorrectionParentContext = () => writable([]);
var provideScaleCorrection = (isCustom) => {
  const fromParent = getContext(ScaleCorrectionContext) || ScaleCorrectionContext(isCustom);
  const ctx = ScaleCorrectionContext();
  setContext(ScaleCorrectionContext, ctx);
  setDomContext("ScaleCorrection", isCustom, ctx);
  setContext(ScaleCorrectionParentContext, fromParent);
};
function ScaleCorrectionProvider($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ScaleCorrectionProvider);
  let isCustom = prop($$props, "isCustom", 8);
  provideScaleCorrection(isCustom());
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ScaleCorrectionProvider = hmr(ScaleCorrectionProvider, () => ScaleCorrectionProvider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ScaleCorrectionProvider[HMR].source;
    set(ScaleCorrectionProvider[HMR].source, module.default[HMR].original);
  });
}
var ScaleCorrectionProvider_default = ScaleCorrectionProvider;
mark_module_end(ScaleCorrectionProvider);

// node_modules/svelte-motion/src/components/MotionConfig/MotionConfigScaleCorrection.js
var scaleCorrection = () => {
  const scaleCorrectionContext = getContext(ScaleCorrectionContext);
  const scaleCorrectionParentContext = getContext(
    ScaleCorrectionParentContext
  );
  const afterU = (nc = false) => {
    const scc = get2(scaleCorrectionContext);
    scc.forEach((v, i) => {
      var _a;
      (_a = v.afterU) == null ? void 0 : _a.call(v, true);
    });
  };
  const updater = () => {
    get2(scaleCorrectionContext).forEach((v) => {
      var _a;
      (_a = v.updater) == null ? void 0 : _a.call(v, true);
    });
  };
  scaleCorrectionParentContext.update(
    (v) => v.concat([
      {
        updater,
        afterU
      }
    ])
  );
  return {
    update: updater
  };
};

// node_modules/svelte-motion/src/components/MotionConfig/MotionConfig.svelte
mark_module_start();
MotionConfig[FILENAME] = "node_modules/svelte-motion/src/components/MotionConfig/MotionConfig.svelte";
function MotionConfig($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, MotionConfig);
  const [$$stores, $$cleanup] = setup_stores();
  const $mcc = () => (validate_store(mcc, "mcc"), store_get(mcc, "$mcc", $$stores));
  const transitionDependency = mutable_source();
  let transformPagePoint = prop($$props, "transformPagePoint", 8, void 0), isStatic = prop($$props, "isStatic", 8, void 0), transition = prop($$props, "transition", 8, void 0), isCustom = prop($$props, "isCustom", 8, false);
  const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom());
  let config = mutable_source({
    ...get2(mcc),
    ...{
      transformPagePoint: transformPagePoint(),
      isStatic: isStatic(),
      transition: transition()
    }
  });
  provideScaleCorrection();
  let context = writable(get(config));
  setContext(MotionConfigContext, context);
  setDomContext("Motion", isCustom(), context);
  const memo = () => get(config);
  const scaleCorrector = scaleCorrection();
  legacy_pre_effect(
    () => ($mcc(), deep_read_state(transformPagePoint()), deep_read_state(isStatic()), deep_read_state(transition())),
    () => {
      set(config, {
        ...$mcc(),
        ...{
          transformPagePoint: transformPagePoint(),
          isStatic: isStatic(),
          transition: transition()
        }
      });
    }
  );
  legacy_pre_effect(() => get(config), () => {
    set(transitionDependency, strict_equals(typeof get(config).transition, "object") ? get(config).transition.toString() : "");
  });
  legacy_pre_effect(
    () => (get(transitionDependency), get(config)),
    () => {
      context.set(memo(get(transitionDependency), get(config).transformPagePoint));
      scaleCorrector.update();
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  MotionConfig = hmr(MotionConfig, () => MotionConfig[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MotionConfig[HMR].source;
    set(MotionConfig[HMR].source, module.default[HMR].original);
  });
}
var MotionConfig_default = MotionConfig;
mark_module_end(MotionConfig);

// node_modules/svelte-motion/src/render/utils/animation.js
import { __read as __read5, __rest as __rest3 } from "tslib";

// node_modules/svelte-motion/src/animation/utils/transitions.js
import { __rest, __spreadArray, __read as __read2 } from "tslib";
import { inertia, animate } from "popmotion";

// node_modules/svelte-motion/src/utils/time-conversion.js
var secondsToMilliseconds = function(seconds) {
  return seconds * 1e3;
};

// node_modules/svelte-motion/src/animation/utils/easing.js
import { __read } from "tslib";
import { cubicBezier, linear, easeIn, easeInOut, easeOut, circIn, circInOut, circOut, backIn, backInOut, backOut, anticipate, bounceIn, bounceInOut, bounceOut } from "popmotion";
var easingLookup = {
  linear,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
  bounceIn,
  bounceInOut,
  bounceOut
};
var easingDefinitionToFunction = function(definition) {
  if (Array.isArray(definition)) {
    var _a = __read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    return easingLookup[definition];
  }
  return definition;
};
var isEasingArray = function(ease) {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};

// node_modules/svelte-motion/src/animation/utils/is-animatable.js
import { complex } from "style-value-types";
var isAnimatable = function(key, value) {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  complex.test(value) && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};

// node_modules/svelte-motion/src/animation/utils/is-keyframes-target.js
var isKeyframesTarget = function(v) {
  return Array.isArray(v);
};

// node_modules/svelte-motion/src/animation/utils/default-transitions.js
var underDampedSpring = function() {
  return {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restDelta: 0.5,
    restSpeed: 10
  };
};
var criticallyDampedSpring = function(to) {
  return {
    type: "spring",
    stiffness: 550,
    damping: to === 0 ? 2 * Math.sqrt(550) : 30,
    restDelta: 0.01,
    restSpeed: 10
  };
};
var linearTween = function() {
  return {
    type: "keyframes",
    ease: "linear",
    duration: 0.3
  };
};
var keyframes = function(values) {
  return {
    type: "keyframes",
    duration: 0.8,
    values
  };
};
var defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
var getDefaultTransition = function(valueKey, to) {
  var transitionFactory;
  if (isKeyframesTarget(to)) {
    transitionFactory = keyframes;
  } else {
    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
  }
  return Object.assign({ to }, transitionFactory(to));
};

// node_modules/svelte-motion/src/animation/utils/transitions.js
import { warning } from "hey-listen";

// node_modules/svelte-motion/src/render/dom/value-types/animatable-none.js
import { filter as filter2, complex as complex2 } from "style-value-types";

// node_modules/svelte-motion/src/render/dom/value-types/defaults.js
import { color, filter } from "style-value-types";

// node_modules/svelte-motion/src/render/dom/value-types/number.js
import { px, degrees, scale, alpha, progressPercentage } from "style-value-types";

// node_modules/svelte-motion/src/render/dom/value-types/type-int.js
import { number } from "style-value-types";
var int = Object.assign(Object.assign({}, number), { transform: Math.round });

// node_modules/svelte-motion/src/render/dom/value-types/number.js
var numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

// node_modules/svelte-motion/src/render/dom/value-types/defaults.js
var defaultValueTypes = Object.assign(Object.assign({}, numberValueTypes), {
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
});
var getDefaultValueType = function(key) {
  return defaultValueTypes[key];
};

// node_modules/svelte-motion/src/render/dom/value-types/animatable-none.js
function getAnimatableNone(key, value) {
  var _a;
  var defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter2)
    defaultValueType = complex2;
  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);
}

// node_modules/svelte-motion/src/animation/utils/transitions.js
function isTransitionDefined(_a) {
  _a.when;
  _a.delay;
  _a.delayChildren;
  _a.staggerChildren;
  _a.staggerDirection;
  _a.repeat;
  _a.repeatType;
  _a.repeatDelay;
  _a.from;
  var transition = __rest(_a, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);
  return !!Object.keys(transition).length;
}
var legacyRepeatWarning = false;
function convertTransitionToAnimationOptions(_a) {
  var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = __rest(_a, ["ease", "times", "yoyo", "flip", "loop"]);
  var options = Object.assign({}, transition);
  if (times)
    options["offset"] = times;
  if (transition.duration)
    options["duration"] = secondsToMilliseconds(transition.duration);
  if (transition.repeatDelay)
    options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);
  if (ease) {
    options["ease"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  }
  if (transition.type === "tween")
    options.type = "keyframes";
  if (yoyo || loop || flip) {
    warning(!legacyRepeatWarning, "yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.");
    legacyRepeatWarning = true;
    if (yoyo) {
      options.repeatType = "reverse";
    } else if (loop) {
      options.repeatType = "loop";
    } else if (flip) {
      options.repeatType = "mirror";
    }
    options.repeat = loop || yoyo || flip || transition.repeat;
  }
  if (transition.type !== "spring")
    options.type = "keyframes";
  return options;
}
function getDelayFromTransition(transition, key) {
  var _a;
  var valueTransition = getValueTransition(transition, key) || {};
  return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;
}
function hydrateKeyframes(options) {
  if (Array.isArray(options.to) && options.to[0] === null) {
    options.to = __spreadArray([], __read2(options.to));
    options.to[0] = options.from;
  }
  return options;
}
function getPopmotionAnimationOptions(transition, options, key) {
  var _a;
  if (Array.isArray(options.to)) {
    (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;
  }
  hydrateKeyframes(options);
  if (!isTransitionDefined(transition)) {
    transition = Object.assign(Object.assign({}, transition), getDefaultTransition(key, options.to));
  }
  return Object.assign(Object.assign({}, options), convertTransitionToAnimationOptions(transition));
}
function getAnimation(key, value, target, transition, onComplete) {
  var _a;
  var valueTransition = getValueTransition(transition, key);
  var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();
  var isTargetAnimatable = isAnimatable(key, target);
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    origin = getAnimatableNone(key, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  var isOriginAnimatable = isAnimatable(key, origin);
  warning(isOriginAnimatable === isTargetAnimatable, "You are trying to animate " + key + ' from "' + origin + '" to "' + target + '". ' + origin + " is not an animatable value - to enable this animation set " + origin + " to a value animatable to " + target + " via the `style` property.");
  function start() {
    var options = {
      from: origin,
      to: target,
      velocity: value.getVelocity(),
      onComplete,
      onUpdate: function(v) {
        return value.set(v);
      }
    };
    return valueTransition.type === "inertia" || valueTransition.type === "decay" ? inertia(Object.assign(Object.assign({}, options), valueTransition)) : animate(Object.assign(Object.assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function(v) {
      var _a2;
      options.onUpdate(v);
      (_a2 = valueTransition.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition, v);
    }, onComplete: function() {
      var _a2;
      options.onComplete();
      (_a2 = valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);
    } }));
  }
  function set2() {
    var _a2;
    value.set(target);
    onComplete();
    (_a2 = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);
    return { stop: function() {
    } };
  }
  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set2 : start;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone("", potentialUnitType);
}
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}
function startAnimation(key, value, target, transition) {
  if (transition === void 0) {
    transition = {};
  }
  return value.start(function(onComplete) {
    var delayTimer;
    var controls;
    var animation = getAnimation(key, value, target, transition, onComplete);
    var delay = getDelayFromTransition(transition, key);
    var start = function() {
      return controls = animation();
    };
    if (delay) {
      delayTimer = setTimeout(start, secondsToMilliseconds(delay));
    } else {
      start();
    }
    return function() {
      clearTimeout(delayTimer);
      controls === null || controls === void 0 ? void 0 : controls.stop();
    };
  });
}

// node_modules/svelte-motion/src/render/utils/setters.js
import { __rest as __rest2, __spreadArray as __spreadArray3, __read as __read4 } from "tslib";
import { complex as complex4 } from "style-value-types";

// node_modules/svelte-motion/src/utils/is-numerical-string.js
var isNumericalString = function(v) {
  return /^\-?\d*\.?\d+$/.test(v);
};

// node_modules/svelte-motion/src/utils/resolve-value.js
var isCustomValue = function(v) {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
var resolveFinalValueInKeyframes = function(v) {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};

// node_modules/svelte-motion/src/render/dom/value-types/find.js
import { __spreadArray as __spreadArray2, __read as __read3 } from "tslib";
import { color as color2, complex as complex3 } from "style-value-types";

// node_modules/svelte-motion/src/render/dom/value-types/dimensions.js
import { number as number2, px as px2, percent, degrees as degrees2, vw, vh } from "style-value-types";

// node_modules/svelte-motion/src/render/dom/value-types/test.js
var testValueType = function(v) {
  return function(type) {
    return type.test(v);
  };
};

// node_modules/svelte-motion/src/render/dom/value-types/type-auto.js
var auto = {
  test: function(v) {
    return v === "auto";
  },
  parse: function(v) {
    return v;
  }
};

// node_modules/svelte-motion/src/render/dom/value-types/dimensions.js
var dimensionValueTypes = [number2, px2, percent, degrees2, vw, vh, auto];
var findDimensionValueType = function(v) {
  return dimensionValueTypes.find(testValueType(v));
};

// node_modules/svelte-motion/src/render/dom/value-types/find.js
var valueTypes = __spreadArray2(__spreadArray2([], __read3(dimensionValueTypes)), [color2, complex3]);
var findValueType = function(v) {
  return valueTypes.find(testValueType(v));
};

// node_modules/svelte-motion/src/render/utils/variants.js
function isVariantLabels(v) {
  return Array.isArray(v);
}
function isVariantLabel(v) {
  return typeof v === "string" || isVariantLabels(v);
}
function getCurrent(visualElement2) {
  var current = {};
  visualElement2.forEachValue(function(value, key) {
    return current[key] = value.get();
  });
  return current;
}
function getVelocity(visualElement2) {
  var velocity = {};
  visualElement2.forEachValue(function(value, key) {
    return velocity[key] = value.getVelocity();
  });
  return velocity;
}
function resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {
  var _a;
  if (currentValues === void 0) {
    currentValues = {};
  }
  if (currentVelocity === void 0) {
    currentVelocity = {};
  }
  if (typeof definition === "string") {
    definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];
  }
  return typeof definition === "function" ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity) : definition;
}
function resolveVariant(visualElement2, definition, custom) {
  var props = visualElement2.getProps();
  return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement2), getVelocity(visualElement2));
}
function checkIfControllingVariants(props) {
  var _a;
  return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === "function" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);
}
function checkIfVariantNode(props) {
  return Boolean(checkIfControllingVariants(props) || props.variants);
}

// node_modules/svelte-motion/src/render/utils/setters.js
function setMotionValue(visualElement2, key, value) {
  if (visualElement2.hasValue(key)) {
    visualElement2.getValue(key).set(value);
  } else {
    visualElement2.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement2, definition) {
  var resolved = resolveVariant(visualElement2, definition);
  var _a = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b;
  _a.transition;
  var target = __rest2(_a, ["transitionEnd", "transition"]);
  target = Object.assign(Object.assign({}, target), transitionEnd);
  for (var key in target) {
    var value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement2, key, value);
  }
}
function setVariants(visualElement2, variantLabels) {
  var reversedLabels = __spreadArray3([], __read4(variantLabels)).reverse();
  reversedLabels.forEach(function(key) {
    var _a;
    var variant = visualElement2.getVariant(key);
    variant && setTarget(visualElement2, variant);
    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child2) {
      setVariants(child2, variantLabels);
    });
  });
}
function setValues(visualElement2, definition) {
  if (Array.isArray(definition)) {
    return setVariants(visualElement2, definition);
  } else if (typeof definition === "string") {
    return setVariants(visualElement2, [definition]);
  } else {
    setTarget(visualElement2, definition);
  }
}
function checkTargetForNewValues(visualElement2, target, origin) {
  var _a, _b, _c;
  var _d;
  var newValueKeys = Object.keys(target).filter(function(key2) {
    return !visualElement2.hasValue(key2);
  });
  var numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (var i = 0; i < numNewValues; i++) {
    var key = newValueKeys[i];
    var targetValue = target[key];
    var value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement2.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && isNumericalString(value)) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex4.test(targetValue)) {
      value = getAnimatableNone(key, targetValue);
    }
    visualElement2.addValue(key, motionValue(value));
    (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;
    visualElement2.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition) {
  if (!transition)
    return;
  var valueTransition = transition[key] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement2) {
  var _a, _b;
  var origin = {};
  for (var key in target) {
    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement2.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();
  }
  return origin;
}

// node_modules/svelte-motion/src/render/utils/animation.js
function animateVisualElement(visualElement2, definition, options) {
  if (options === void 0) {
    options = {};
  }
  visualElement2.notifyAnimationStart();
  var animation;
  if (Array.isArray(definition)) {
    var animations2 = definition.map(function(variant) {
      return animateVariant(visualElement2, variant, options);
    });
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement2, definition, options);
  } else {
    var resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement2, definition, options.custom) : definition;
    animation = animateTarget(visualElement2, resolvedDefinition, options);
  }
  return animation.then(function() {
    return visualElement2.notifyAnimationComplete(definition);
  });
}
function animateVariant(visualElement2, variant, options) {
  var _a;
  if (options === void 0) {
    options = {};
  }
  var resolved = resolveVariant(visualElement2, variant, options.custom);
  var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement2.getDefaultTransition() || {} : _b;
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  var getAnimation2 = resolved ? function() {
    return animateTarget(visualElement2, resolved, options);
  } : function() {
    return Promise.resolve();
  };
  var getChildAnimations = ((_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function(forwardDelay) {
    if (forwardDelay === void 0) {
      forwardDelay = 0;
    }
    var _a2 = transition.delayChildren, delayChildren = _a2 === void 0 ? 0 : _a2, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;
    return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : function() {
    return Promise.resolve();
  };
  var when = transition.when;
  if (when) {
    var _c = __read5(when === "beforeChildren" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2], 2), first = _c[0], last = _c[1];
    return first().then(last);
  } else {
    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);
  }
}
function animateTarget(visualElement2, definition, _a) {
  var _b;
  var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;
  var _e = visualElement2.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement2.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = __rest3(_e, ["transition", "transitionEnd"]);
  if (transitionOverride)
    transition = transitionOverride;
  var animations2 = [];
  var animationTypeState = type && ((_b = visualElement2.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);
  for (var key in target) {
    var value = visualElement2.getValue(key);
    var valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    var animation = startAnimation(key, value, valueTarget, Object.assign({ delay }, transition));
    animations2.push(animation);
  }
  return Promise.all(animations2).then(function() {
    transitionEnd && setTarget(visualElement2, transitionEnd);
  });
}
function animateChildren(visualElement2, variant, delayChildren, staggerChildren, staggerDirection, options) {
  if (delayChildren === void 0) {
    delayChildren = 0;
  }
  if (staggerChildren === void 0) {
    staggerChildren = 0;
  }
  if (staggerDirection === void 0) {
    staggerDirection = 1;
  }
  var animations2 = [];
  var maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;
  var generateStaggerDuration = staggerDirection === 1 ? function(i) {
    if (i === void 0) {
      i = 0;
    }
    return i * staggerChildren;
  } : function(i) {
    if (i === void 0) {
      i = 0;
    }
    return maxStaggerDuration - i * staggerChildren;
  };
  Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach(function(child2, i) {
    animations2.push(animateVariant(child2, variant, Object.assign(Object.assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function() {
      return child2.notifyAnimationComplete(variant);
    }));
  });
  return Promise.all(animations2);
}
function stopAnimation(visualElement2) {
  visualElement2.forEachValue(function(value) {
    return value.stop();
  });
}
function sortByTreeOrder(a, b) {
  return a.sortNodePosition(b);
}
function shouldBlockAnimation(_a, key) {
  var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;
  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}

// node_modules/svelte-motion/src/animation/animation-controls.js
import { __spreadArray as __spreadArray4, __read as __read6 } from "tslib";
function animationControls(startStopNotifier) {
  var hasMounted = false;
  var pendingAnimations = [];
  var subscribers = /* @__PURE__ */ new Set();
  var stopNotification;
  var controls = {
    subscribe: function(visualElement2) {
      if (subscribers.size === 0) {
        stopNotification = startStopNotifier == null ? void 0 : startStopNotifier();
      }
      subscribers.add(visualElement2);
      return function() {
        subscribers.delete(visualElement2);
        if (subscribers.size === 0) {
          stopNotification == null ? void 0 : stopNotification();
        }
      };
    },
    start: function(definition, transitionOverride) {
      if (hasMounted) {
        var animations_1 = [];
        subscribers.forEach(function(visualElement2) {
          animations_1.push(animateVisualElement(visualElement2, definition, {
            transitionOverride
          }));
        });
        return Promise.all(animations_1);
      } else {
        return new Promise(function(resolve) {
          pendingAnimations.push({
            animation: [definition, transitionOverride],
            resolve
          });
        });
      }
    },
    set: function(definition) {
      return subscribers.forEach(function(visualElement2) {
        setValues(visualElement2, definition);
      });
    },
    stop: function() {
      subscribers.forEach(function(visualElement2) {
        stopAnimation(visualElement2);
      });
    },
    mount: function() {
      hasMounted = true;
      pendingAnimations.forEach(function(_a) {
        var animation = _a.animation, resolve = _a.resolve;
        controls.start.apply(controls, __spreadArray4([], __read6(animation))).then(resolve);
      });
      return function() {
        hasMounted = false;
        controls.stop();
      };
    }
  };
  return controls;
}

// node_modules/svelte-motion/src/render/dom/projection/scale-correction.js
var valueScaleCorrection = {};
function addScaleCorrection(correctors) {
  for (var key in correctors) {
    valueScaleCorrection[key] = correctors[key];
  }
}

// node_modules/svelte-motion/src/render/index.js
import { __spreadArray as __spreadArray7, __read as __read10 } from "tslib";
import sync2, { cancelSync } from "framesync";
import { pipe } from "popmotion";

// node_modules/svelte-motion/src/utils/each-axis.js
function eachAxis(handler) {
  return [handler("x"), handler("y")];
}

// node_modules/svelte-motion/src/utils/noop.js
function noop(any) {
  return any;
}

// node_modules/svelte-motion/src/utils/geometry/index.js
function convertBoundingBoxToAxisBox(_a) {
  var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertAxisBoxToBoundingBox(_a) {
  var x = _a.x, y = _a.y;
  return {
    top: y.min,
    bottom: y.max,
    left: x.min,
    right: x.max
  };
}
function transformBoundingBox(_a, transformPoint2) {
  var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
  if (transformPoint2 === void 0) {
    transformPoint2 = noop;
  }
  var topLeft = transformPoint2({ x: left, y: top });
  var bottomRight = transformPoint2({ x: right, y: bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function axisBox() {
  return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };
}
function copyAxisBox(box) {
  return {
    x: Object.assign({}, box.x),
    y: Object.assign({}, box.y)
  };
}
var zeroDelta = {
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
};
function delta() {
  return {
    x: Object.assign({}, zeroDelta),
    y: Object.assign({}, zeroDelta)
  };
}

// node_modules/svelte-motion/src/utils/geometry/delta-apply.js
import { __read as __read7 } from "tslib";
import { mix } from "popmotion";

// node_modules/svelte-motion/src/render/utils/is-draggable.js
function isDraggable(visualElement2) {
  var _a = visualElement2.getProps(), drag2 = _a.drag, _dragX = _a._dragX;
  return drag2 && !_dragX;
}

// node_modules/svelte-motion/src/utils/geometry/delta-apply.js
function resetAxis(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function resetBox(box, originBox) {
  resetAxis(box.x, originBox.x);
  resetAxis(box.y, originBox.y);
}
function scalePoint(point, scale2, originPoint) {
  var distanceFromOrigin = point - originPoint;
  var scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate, scale2, originPoint, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, _a) {
  var x = _a.x, y = _a.y;
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
function applyAxisTransforms(final, axis, transforms, _a) {
  var _b = __read7(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  final.min = axis.min;
  final.max = axis.max;
  var axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  var originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
}
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function applyBoxTransforms(finalBox, box, transforms) {
  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);
  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate, scale2, origin, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  if (origin === void 0) {
    origin = 0.5;
  }
  var originPoint = mix(axis.min, axis.max, origin) - translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, _a) {
  var _b = __read7(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);
}
function removeBoxTransforms(box, transforms) {
  removeAxisTransforms(box.x, transforms, xKeys);
  removeAxisTransforms(box.y, transforms, yKeys);
}
function applyTreeDeltas(box, treeScale, treePath) {
  var treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  var node;
  var delta2;
  for (var i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta2 = node.getLayoutState().delta;
    treeScale.x *= delta2.x.scale;
    treeScale.y *= delta2.y.scale;
    applyBoxDelta(box, delta2);
    if (isDraggable(node)) {
      applyBoxTransforms(box, box, node.getLatestValues());
    }
  }
}

// node_modules/svelte-motion/src/utils/geometry/delta-calc.js
import { mix as mix2, distance, clamp, progress } from "popmotion";
var clampProgress = function(v) {
  return clamp(0, 1, v);
};
function isNear(value, target, maxDistance) {
  if (target === void 0) {
    target = 0;
  }
  if (maxDistance === void 0) {
    maxDistance = 0.01;
  }
  return distance(value, target) < maxDistance;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function calcOrigin(source, target) {
  var origin = 0.5;
  var sourceLength = calcLength(source);
  var targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clampProgress(origin);
}
function updateAxisDelta(delta2, source, target, origin) {
  if (origin === void 0) {
    origin = 0.5;
  }
  delta2.origin = origin;
  delta2.originPoint = mix2(source.min, source.max, delta2.origin);
  delta2.scale = calcLength(target) / calcLength(source);
  if (isNear(delta2.scale, 1, 1e-4))
    delta2.scale = 1;
  delta2.translate = mix2(target.min, target.max, delta2.origin) - delta2.originPoint;
  if (isNear(delta2.translate))
    delta2.translate = 0;
}
function updateBoxDelta(delta2, source, target, origin) {
  updateAxisDelta(delta2.x, source.x, target.x, defaultOrigin(origin.originX));
  updateAxisDelta(delta2.y, source.y, target.y, defaultOrigin(origin.originY));
}
function defaultOrigin(origin) {
  return typeof origin === "number" ? origin : 0.5;
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(projection, parentProjection) {
  calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);
  calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);
}

// node_modules/svelte-motion/src/value/utils/is-motion-value.js
var isMotionValue = function(value) {
  return value !== null && typeof value === "object" && value.getVelocity;
};

// node_modules/svelte-motion/src/render/utils/state.js
var createProjectionState = function() {
  return {
    isEnabled: false,
    isTargetLocked: false,
    target: axisBox(),
    targetFinal: axisBox()
  };
};
function createLayoutState() {
  return {
    isHydrated: false,
    layout: axisBox(),
    layoutCorrected: axisBox(),
    treeScale: { x: 1, y: 1 },
    delta: delta(),
    deltaFinal: delta(),
    deltaTransform: ""
  };
}
var zeroLayout = createLayoutState();

// node_modules/svelte-motion/src/render/html/utils/build-projection-transform.js
function buildLayoutProjectionTransform(_a, treeScale, latestTransform) {
  var x = _a.x, y = _a.y;
  var xTranslate = x.translate / treeScale.x;
  var yTranslate = y.translate / treeScale.y;
  var transform2 = "translate3d(" + xTranslate + "px, " + yTranslate + "px, 0) ";
  if (latestTransform) {
    var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;
    if (rotate)
      transform2 += "rotate(" + rotate + ") ";
    if (rotateX)
      transform2 += "rotateX(" + rotateX + ") ";
    if (rotateY)
      transform2 += "rotateY(" + rotateY + ") ";
  }
  transform2 += "scale(" + x.scale + ", " + y.scale + ")";
  return !latestTransform && transform2 === identityProjection ? "" : transform2;
}
function buildLayoutProjectionTransformOrigin(_a) {
  var deltaFinal = _a.deltaFinal;
  return deltaFinal.x.origin * 100 + "% " + deltaFinal.y.origin * 100 + "% 0";
}
var identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });

// node_modules/svelte-motion/src/render/utils/animation-state.js
import { __spreadArray as __spreadArray5, __read as __read8, __rest as __rest4 } from "tslib";

// node_modules/svelte-motion/src/animation/utils/is-animation-controls.js
var isAnimationControls = function(v) {
  return typeof v === "object" && typeof v.start === "function";
};

// node_modules/svelte-motion/src/utils/shallow-compare.js
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  var prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (var i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}

// node_modules/svelte-motion/src/render/utils/types.js
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));

// node_modules/svelte-motion/src/render/utils/animation-state.js
var variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Focus,
  AnimationType.Exit
];
var reversePriorityOrder = __spreadArray5([], __read8(variantPriorityOrder)).reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement2) {
  return function(animations2) {
    return Promise.all(animations2.map(function(_a) {
      var animation = _a.animation, options = _a.options;
      return animateVisualElement(visualElement2, animation, options);
    }));
  };
}
function createAnimationState(visualElement2) {
  var animate4 = animateList(visualElement2);
  var state = createState();
  var allAnimatedKeys = {};
  var isInitialRender = true;
  var buildResolvedTypeValues = function(acc, definition) {
    var resolved = resolveVariant(visualElement2, definition);
    if (resolved) {
      resolved.transition;
      var transitionEnd = resolved.transitionEnd, target = __rest4(resolved, ["transition", "transitionEnd"]);
      acc = Object.assign(Object.assign(Object.assign({}, acc), target), transitionEnd);
    }
    return acc;
  };
  function isAnimated(key) {
    return allAnimatedKeys[key] !== void 0;
  }
  function setAnimateFunction(makeAnimator) {
    animate4 = makeAnimator(visualElement2);
  }
  function animateChanges(options, changedActiveType) {
    var _a;
    var props = visualElement2.getProps();
    var context = visualElement2.getVariantContext(true) || {};
    var animations2 = [];
    var removedKeys = /* @__PURE__ */ new Set();
    var encounteredKeys = {};
    var removedVariantIndex = Infinity;
    var _loop_1 = function(i2) {
      var type = reversePriorityOrder[i2];
      var typeState = state[type];
      var prop2 = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];
      var propIsVariant = isVariantLabel(prop2);
      var activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      var isInherited = prop2 === context[type] && prop2 !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = Object.assign({}, encounteredKeys);
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop2 && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop2) || typeof prop2 === "boolean"
      ) {
        return "continue";
      }
      var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop2) || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      var definitionList = Array.isArray(prop2) ? prop2 : [prop2];
      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;
      var allKeys = Object.assign(Object.assign({}, prevResolvedValues), resolvedValues);
      var markToAnimate = function(key2) {
        shouldAnimateType = true;
        removedKeys.delete(key2);
        typeState.needsAnimating[key2] = true;
      };
      for (var key in allKeys) {
        var next = resolvedValues[key];
        var prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev)) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop2;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = Object.assign(Object.assign({}, encounteredKeys), resolvedValues);
      }
      if (isInitialRender && visualElement2.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push.apply(animations2, __spreadArray5([], __read8(definitionList.map(function(animation) {
          return {
            animation,
            options: Object.assign({ type }, options)
          };
        }))));
      }
    };
    for (var i = 0; i < numAnimationTypes; i++) {
      _loop_1(i);
    }
    allAnimatedKeys = Object.assign({}, encounteredKeys);
    if (removedKeys.size) {
      var fallbackAnimation_1 = {};
      removedKeys.forEach(function(key) {
        var fallbackTarget = visualElement2.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation_1[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation_1 });
    }
    var shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate4(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child2) {
      var _a2;
      return (_a2 = child2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    return animateChanges(options, type);
  }
  return {
    isAnimated,
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: function() {
      return state;
    }
  };
}
function variantsHaveChanged(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (isVariantLabels(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive) {
  if (isActive === void 0) {
    isActive = false;
  }
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  var _a;
  return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;
}

// node_modules/svelte-motion/src/render/utils/lifecycles.js
import { __spreadArray as __spreadArray6, __read as __read9 } from "tslib";
var names = [
  "LayoutMeasure",
  "BeforeLayoutMeasure",
  "LayoutUpdate",
  "ViewportBoxUpdate",
  "Update",
  "Render",
  "AnimationComplete",
  "LayoutAnimationComplete",
  "AnimationStart",
  "SetAxisTarget",
  "Unmount"
];
function createLifecycles() {
  var managers = names.map(function() {
    return new SubscriptionManager();
  });
  var propSubscriptions = {};
  var lifecycles = {
    clearAllListeners: function() {
      return managers.forEach(function(manager) {
        return manager.clear();
      });
    },
    updatePropListeners: function(props) {
      return names.forEach(function(name) {
        var _a;
        (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);
        var on = "on" + name;
        var propListener = props[on];
        if (propListener) {
          propSubscriptions[name] = lifecycles[on](propListener);
        }
      });
    }
  };
  managers.forEach(function(manager, i) {
    lifecycles["on" + names[i]] = function(handler) {
      return manager.add(handler);
    };
    lifecycles["notify" + names[i]] = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return manager.notify.apply(manager, __spreadArray6([], __read9(args)));
    };
  });
  return lifecycles;
}

// node_modules/svelte-motion/src/render/utils/motion-values.js
function updateMotionValuesFromProps(element2, next, prev) {
  var _a;
  for (var key in next) {
    var nextValue = next[key];
    var prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element2.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element2.addValue(key, motionValue(nextValue));
    } else if (prevValue !== nextValue) {
      if (element2.hasValue(key)) {
        var existingValue = element2.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        element2.addValue(key, motionValue((_a = element2.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));
      }
    }
  }
  for (var key in prev) {
    if (next[key] === void 0)
      element2.removeValue(key);
  }
  return next;
}

// node_modules/svelte-motion/src/render/utils/projection.js
function updateLayoutDeltas(_a, _b, treePath, transformOrigin) {
  var delta2 = _a.delta, layout = _a.layout, layoutCorrected = _a.layoutCorrected, treeScale = _a.treeScale;
  var target = _b.target;
  resetBox(layoutCorrected, layout);
  applyTreeDeltas(layoutCorrected, treeScale, treePath);
  updateBoxDelta(delta2, layoutCorrected, target, transformOrigin);
}

// node_modules/svelte-motion/src/render/utils/compare-by-depth.js
var compareByDepth = function(a, b) {
  return a.depth - b.depth;
};

// node_modules/svelte-motion/src/render/utils/flat-tree.js
var FlatTree = (
  /** @class */
  function() {
    function FlatTree2() {
      this.children = [];
      this.isDirty = false;
    }
    FlatTree2.prototype.add = function(child2) {
      addUniqueItem(this.children, child2);
      this.isDirty = true;
    };
    FlatTree2.prototype.remove = function(child2) {
      removeItem(this.children, child2);
      this.isDirty = true;
    };
    FlatTree2.prototype.forEach = function(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      var numChildren = this.children.length;
      for (var i = 0; i < numChildren; i++) {
        callback(this.children[i]);
      }
    };
    return FlatTree2;
  }()
);

// node_modules/svelte-motion/src/motion/features/layout/utils.js
import { mix as mix3 } from "popmotion";
function tweenAxis(target, prev, next, p) {
  target.min = mix3(prev.min, next.min, p);
  target.max = mix3(prev.max, next.max, p);
}
function calcRelativeOffsetAxis(parent, child2) {
  return {
    min: child2.min - parent.min,
    max: child2.max - parent.min
  };
}
function calcRelativeOffset(parent, child2) {
  return {
    x: calcRelativeOffsetAxis(parent.x, child2.x),
    y: calcRelativeOffsetAxis(parent.y, child2.y)
  };
}

// node_modules/svelte-motion/src/render/dom/projection/relative-set.js
function setCurrentViewportBox(visualElement2) {
  var projectionParent = visualElement2.getProjectionParent();
  if (!projectionParent) {
    visualElement2.rebaseProjectionTarget();
    return;
  }
  var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement2.getLayoutState().layout);
  eachAxis(function(axis) {
    visualElement2.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);
  });
}

// node_modules/svelte-motion/src/render/index.js
var visualElement = function(_a) {
  var _b = _a.treeType, treeType = _b === void 0 ? "" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps3 = _a.scrapeMotionValuesFromProps;
  return function(_a2, options) {
    var parent = _a2.parent, props = _a2.props, presenceId2 = _a2.presenceId, blockInitialAnimation = _a2.blockInitialAnimation, visualState = _a2.visualState;
    if (options === void 0) {
      options = {};
    }
    var latestValues = visualState.latestValues, renderState = visualState.renderState;
    var instance;
    var lifecycles = createLifecycles();
    var projection = createProjectionState();
    var projectionParent;
    var leadProjection = projection;
    var leadLatestValues = latestValues;
    var unsubscribeFromLeadVisualElement;
    var layoutState2 = createLayoutState();
    var crossfader;
    var hasViewportBoxUpdated = false;
    var values = /* @__PURE__ */ new Map();
    var valueSubscriptions = /* @__PURE__ */ new Map();
    var prevMotionValues = {};
    var projectionTargetProgress;
    var baseTarget = Object.assign({}, latestValues);
    var removeFromVariantTree;
    function render() {
      if (!instance)
        return;
      if (element2.isProjectionReady()) {
        applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);
        updateBoxDelta(layoutState2.deltaFinal, layoutState2.layoutCorrected, leadProjection.targetFinal, latestValues);
      }
      triggerBuild();
      renderInstance(instance, renderState);
    }
    function triggerBuild() {
      var valuesToRender = latestValues;
      if (crossfader && crossfader.isActive()) {
        var crossfadedValues = crossfader.getCrossfadeState(element2);
        if (crossfadedValues)
          valuesToRender = crossfadedValues;
      }
      build(element2, renderState, valuesToRender, leadProjection, layoutState2, options, props);
    }
    function update() {
      lifecycles.notifyUpdate(latestValues);
    }
    function updateLayoutProjection() {
      if (!element2.isProjectionReady())
        return;
      var delta2 = layoutState2.delta, treeScale = layoutState2.treeScale;
      var prevTreeScaleX = treeScale.x;
      var prevTreeScaleY = treeScale.y;
      var prevDeltaTransform = layoutState2.deltaTransform;
      updateLayoutDeltas(layoutState2, leadProjection, element2.path, latestValues);
      hasViewportBoxUpdated && element2.notifyViewportBoxUpdate(leadProjection.target, delta2);
      hasViewportBoxUpdated = false;
      var deltaTransform = buildLayoutProjectionTransform(delta2, treeScale);
      if (deltaTransform !== prevDeltaTransform || // Also compare calculated treeScale, for values that rely on this only for scale correction
      prevTreeScaleX !== treeScale.x || prevTreeScaleY !== treeScale.y) {
        element2.scheduleRender();
      }
      layoutState2.deltaTransform = deltaTransform;
    }
    function updateTreeLayoutProjection() {
      element2.layoutTree.forEach(fireUpdateLayoutProjection);
    }
    function bindToMotionValue(key2, value2) {
      var removeOnChange = value2.onChange(function(latestValue) {
        latestValues[key2] = latestValue;
        props.onUpdate && sync2.update(update, false, true);
      });
      var removeOnRenderRequest = value2.onRenderRequest(element2.scheduleRender);
      valueSubscriptions.set(key2, function() {
        removeOnChange();
        removeOnRenderRequest();
      });
    }
    var initialMotionValues = scrapeMotionValuesFromProps3(props);
    for (var key in initialMotionValues) {
      var value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
    var isControllingVariants = checkIfControllingVariants(props);
    var isVariantNode = checkIfVariantNode(props);
    var element2 = Object.assign(Object.assign({
      treeType,
      /**
       * This is a mirror of the internal instance prop, which keeps
       * VisualElement type-compatible with React's RefObject.
       */
      current: null,
      /**
       * The depth of this visual element within the visual element tree.
       */
      depth: parent ? parent.depth + 1 : 0,
      parent,
      children: /* @__PURE__ */ new Set(),
      /**
       * An ancestor path back to the root visual element. This is used
       * by layout projection to quickly recurse back up the tree.
       */
      path: parent ? __spreadArray7(__spreadArray7([], __read10(parent.path)), [parent]) : [],
      layoutTree: parent ? parent.layoutTree : new FlatTree(),
      /**
       *
       */
      presenceId: presenceId2,
      projection,
      /**
       * If this component is part of the variant tree, it should track
       * any children that are also part of the tree. This is essentially
       * a shadow tree to simplify logic around how to stagger over children.
       */
      variantChildren: isVariantNode ? /* @__PURE__ */ new Set() : void 0,
      /**
       * Whether this instance is visible. This can be changed imperatively
       * by AnimateSharedLayout, is analogous to CSS's visibility in that
       * hidden elements should take up layout, and needs enacting by the configured
       * render function.
       */
      isVisible: void 0,
      /**
       * Normally, if a component is controlled by a parent's variants, it can
       * rely on that ancestor to trigger animations further down the tree.
       * However, if a component is created after its parent is mounted, the parent
       * won't trigger that mount animation so the child needs to.
       *
       * TODO: This might be better replaced with a method isParentMounted
       */
      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
      /**
       * This can be set by AnimatePresence to force components that mount
       * at the same time as it to mount as if they have initial={false} set.
       */
      blockInitialAnimation,
      /**
       * Determine whether this component has mounted yet. This is mostly used
       * by variant children to determine whether they need to trigger their
       * own animations on mount.
       */
      isMounted: function() {
        return Boolean(instance);
      },
      mount: function(newInstance) {
        instance = element2.current = newInstance;
        element2.pointTo(element2);
        if (isVariantNode && parent && !isControllingVariants) {
          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element2);
        }
        parent === null || parent === void 0 ? void 0 : parent.children.add(element2);
      },
      /**
       *
       */
      unmount: function() {
        cancelSync.update(update);
        cancelSync.render(render);
        cancelSync.preRender(element2.updateLayoutProjection);
        valueSubscriptions.forEach(function(remove) {
          return remove();
        });
        element2.stopLayoutAnimation();
        element2.layoutTree.remove(element2);
        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
        parent === null || parent === void 0 ? void 0 : parent.children.delete(element2);
        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();
        lifecycles.clearAllListeners();
      },
      /**
       * Add a child visual element to our set of children.
       */
      addVariantChild: function(child2) {
        var _a3;
        var closestVariantNode = element2.getClosestVariantNode();
        if (closestVariantNode) {
          (_a3 = closestVariantNode.variantChildren) === null || _a3 === void 0 ? void 0 : _a3.add(child2);
          return function() {
            return closestVariantNode.variantChildren.delete(child2);
          };
        }
      },
      sortNodePosition: function(other) {
        if (!sortNodePosition || treeType !== other.treeType)
          return 0;
        return sortNodePosition(element2.getInstance(), other.getInstance());
      },
      /**
       * Returns the closest variant node in the tree starting from
       * this visual element.
       */
      getClosestVariantNode: function() {
        return isVariantNode ? element2 : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();
      },
      /**
       * A method that schedules an update to layout projections throughout
       * the tree. We inherit from the parent so there's only ever one
       * job scheduled on the next frame - that of the root visual element.
       */
      scheduleUpdateLayoutProjection: parent ? parent.scheduleUpdateLayoutProjection : function() {
        return sync2.preRender(element2.updateTreeLayoutProjection, false, true);
      },
      /**
       * Expose the latest layoutId prop.
       */
      getLayoutId: function() {
        return props.layoutId;
      },
      /**
       * Returns the current instance.
       */
      getInstance: function() {
        return instance;
      },
      /**
       * Get/set the latest static values.
       */
      getStaticValue: function(key2) {
        return latestValues[key2];
      },
      setStaticValue: function(key2, value2) {
        return latestValues[key2] = value2;
      },
      /**
       * Returns the latest motion value state. Currently only used to take
       * a snapshot of the visual element - perhaps this can return the whole
       * visual state
       */
      getLatestValues: function() {
        return latestValues;
      },
      /**
       * Set the visiblity of the visual element. If it's changed, schedule
       * a render to reflect these changes.
       */
      setVisibility: function(visibility) {
        if (element2.isVisible === visibility)
          return;
        element2.isVisible = visibility;
        element2.scheduleRender();
      },
      /**
       * Make a target animatable by Popmotion. For instance, if we're
       * trying to animate width from 100px to 100vw we need to measure 100vw
       * in pixels to determine what we really need to animate to. This is also
       * pluggable to support Framer's custom value types like Color,
       * and CSS variables.
       */
      makeTargetAnimatable: function(target, canMutate) {
        if (canMutate === void 0) {
          canMutate = true;
        }
        return makeTargetAnimatable(element2, target, props, canMutate);
      },
      // Motion values ========================
      /**
       * Add a motion value and bind it to this visual element.
       */
      addValue: function(key2, value2) {
        if (element2.hasValue(key2))
          element2.removeValue(key2);
        values.set(key2, value2);
        latestValues[key2] = value2.get();
        bindToMotionValue(key2, value2);
      },
      /**
       * Remove a motion value and unbind any active subscriptions.
       */
      removeValue: function(key2) {
        var _a3;
        values.delete(key2);
        (_a3 = valueSubscriptions.get(key2)) === null || _a3 === void 0 ? void 0 : _a3();
        valueSubscriptions.delete(key2);
        delete latestValues[key2];
        removeValueFromRenderState(key2, renderState);
      },
      /**
       * Check whether we have a motion value for this key
       */
      hasValue: function(key2) {
        return values.has(key2);
      },
      /**
       * Get a motion value for this key. If called with a default
       * value, we'll create one if none exists.
       */
      getValue: function(key2, defaultValue) {
        var value2 = values.get(key2);
        if (value2 === void 0 && defaultValue !== void 0) {
          value2 = motionValue(defaultValue);
          element2.addValue(key2, value2);
        }
        return value2;
      },
      /**
       * Iterate over our motion values.
       */
      forEachValue: function(callback) {
        return values.forEach(callback);
      },
      /**
       * If we're trying to animate to a previously unencountered value,
       * we need to check for it in our state and as a last resort read it
       * directly from the instance (which might have performance implications).
       */
      readValue: function(key2) {
        var _a3;
        return (_a3 = latestValues[key2]) !== null && _a3 !== void 0 ? _a3 : readValueFromInstance(instance, key2, options);
      },
      /**
       * Set the base target to later animate back to. This is currently
       * only hydrated on creation and when we first read a value.
       */
      setBaseTarget: function(key2, value2) {
        baseTarget[key2] = value2;
      },
      /**
       * Find the base target for a value thats been removed from all animation
       * props.
       */
      getBaseTarget: function(key2) {
        if (getBaseTarget) {
          var target = getBaseTarget(props, key2);
          if (target !== void 0 && !isMotionValue(target))
            return target;
        }
        return baseTarget[key2];
      }
    }, lifecycles), {
      /**
       * Build the renderer state based on the latest visual state.
       */
      build: function() {
        triggerBuild();
        return renderState;
      },
      /**
       * Schedule a render on the next animation frame.
       */
      scheduleRender: function() {
        sync2.render(render, false, true);
      },
      /**
       * Synchronously fire render. It's prefered that we batch renders but
       * in many circumstances, like layout measurement, we need to run this
       * synchronously. However in those instances other measures should be taken
       * to batch reads/writes.
       */
      syncRender: render,
      /**
       * Update the provided props. Ensure any newly-added motion values are
       * added to our map, old ones removed, and listeners updated.
       */
      setProps: function(newProps) {
        props = newProps;
        lifecycles.updatePropListeners(newProps);
        prevMotionValues = updateMotionValuesFromProps(element2, scrapeMotionValuesFromProps3(props), prevMotionValues);
      },
      getProps: function() {
        return props;
      },
      // Variants ==============================
      /**
       * Returns the variant definition with a given name.
       */
      getVariant: function(name) {
        var _a3;
        return (_a3 = props.variants) === null || _a3 === void 0 ? void 0 : _a3[name];
      },
      /**
       * Returns the defined default transition on this component.
       */
      getDefaultTransition: function() {
        return props.transition;
      },
      /**
       * Used by child variant nodes to get the closest ancestor variant props.
       */
      getVariantContext: function(startAtParent) {
        if (startAtParent === void 0) {
          startAtParent = false;
        }
        if (startAtParent)
          return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
        if (!isControllingVariants) {
          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
          if (props.initial !== void 0) {
            context_1.initial = props.initial;
          }
          return context_1;
        }
        var context = {};
        for (var i = 0; i < numVariantProps; i++) {
          var name_1 = variantProps[i];
          var prop2 = props[name_1];
          if (isVariantLabel(prop2) || prop2 === false) {
            context[name_1] = prop2;
          }
        }
        return context;
      },
      // Layout projection ==============================
      /**
       * Enable layout projection for this visual element. Won't actually
       * occur until we also have hydrated layout measurements.
       */
      enableLayoutProjection: function() {
        projection.isEnabled = true;
        element2.layoutTree.add(element2);
      },
      /**
       * Lock the projection target, for instance when dragging, so
       * nothing else can try and animate it.
       */
      lockProjectionTarget: function() {
        projection.isTargetLocked = true;
      },
      unlockProjectionTarget: function() {
        element2.stopLayoutAnimation();
        projection.isTargetLocked = false;
      },
      getLayoutState: function() {
        return layoutState2;
      },
      setCrossfader: function(newCrossfader) {
        crossfader = newCrossfader;
      },
      isProjectionReady: function() {
        return projection.isEnabled && projection.isHydrated && layoutState2.isHydrated;
      },
      /**
       * Start a layout animation on a given axis.
       */
      startLayoutAnimation: function(axis, transition, isRelative) {
        if (isRelative === void 0) {
          isRelative = false;
        }
        var progress4 = element2.getProjectionAnimationProgress()[axis];
        var _a3 = isRelative ? projection.relativeTarget[axis] : projection.target[axis], min = _a3.min, max = _a3.max;
        var length = max - min;
        progress4.clearListeners();
        progress4.set(min);
        progress4.set(min);
        progress4.onChange(function(v) {
          element2.setProjectionTargetAxis(axis, v, v + length, isRelative);
        });
        return element2.animateMotionValue(axis, progress4, 0, transition);
      },
      /**
       * Stop layout animations.
       */
      stopLayoutAnimation: function() {
        eachAxis(function(axis) {
          return element2.getProjectionAnimationProgress()[axis].stop();
        });
      },
      /**
       * Measure the current viewport box with or without transforms.
       * Only measures axis-aligned boxes, rotate and skew must be manually
       * removed with a re-render to work.
       */
      measureViewportBox: function(withTransform) {
        if (withTransform === void 0) {
          withTransform = true;
        }
        var viewportBox = measureViewportBox(instance, options);
        if (!withTransform)
          removeBoxTransforms(viewportBox, latestValues);
        return viewportBox;
      },
      /**
       * Get the motion values tracking the layout animations on each
       * axis. Lazy init if not already created.
       */
      getProjectionAnimationProgress: function() {
        projectionTargetProgress || (projectionTargetProgress = {
          x: motionValue(0),
          y: motionValue(0)
        });
        return projectionTargetProgress;
      },
      /**
       * Update the projection of a single axis. Schedule an update to
       * the tree layout projection.
       */
      setProjectionTargetAxis: function(axis, min, max, isRelative) {
        if (isRelative === void 0) {
          isRelative = false;
        }
        var target;
        if (isRelative) {
          if (!projection.relativeTarget) {
            projection.relativeTarget = axisBox();
          }
          target = projection.relativeTarget[axis];
        } else {
          projection.relativeTarget = void 0;
          target = projection.target[axis];
        }
        projection.isHydrated = true;
        target.min = min;
        target.max = max;
        hasViewportBoxUpdated = true;
        lifecycles.notifySetAxisTarget();
      },
      /**
       * Rebase the projection target on top of the provided viewport box
       * or the measured layout. This ensures that non-animating elements
       * don't fall out of sync differences in measurements vs projections
       * after a page scroll or other relayout.
       */
      rebaseProjectionTarget: function(force, box) {
        if (box === void 0) {
          box = layoutState2.layout;
        }
        var _a3 = element2.getProjectionAnimationProgress(), x = _a3.x, y = _a3.y;
        var shouldRebase = !projection.relativeTarget && !projection.isTargetLocked && !x.isAnimating() && !y.isAnimating();
        if (force || shouldRebase) {
          eachAxis(function(axis) {
            var _a4 = box[axis], min = _a4.min, max = _a4.max;
            element2.setProjectionTargetAxis(axis, min, max);
          });
        }
      },
      /**
       * Notify the visual element that its layout is up-to-date.
       * Currently Animate.tsx uses this to check whether a layout animation
       * needs to be performed.
       */
      notifyLayoutReady: function(config) {
        setCurrentViewportBox(element2);
        element2.notifyLayoutUpdate(layoutState2.layout, element2.prevViewportBox || layoutState2.layout, config);
      },
      /**
       * Temporarily reset the transform of the instance.
       */
      resetTransform: function() {
        return resetTransform(element2, instance, props);
      },
      restoreTransform: function() {
        return restoreTransform(instance, renderState);
      },
      updateLayoutProjection,
      updateTreeLayoutProjection: function() {
        element2.layoutTree.forEach(fireResolveRelativeTargetBox);
        sync2.preRender(updateTreeLayoutProjection, false, true);
      },
      getProjectionParent: function() {
        if (projectionParent === void 0) {
          var foundParent = false;
          for (var i = element2.path.length - 1; i >= 0; i--) {
            var ancestor = element2.path[i];
            if (ancestor.projection.isEnabled) {
              foundParent = ancestor;
              break;
            }
          }
          projectionParent = foundParent;
        }
        return projectionParent;
      },
      resolveRelativeTargetBox: function() {
        var relativeParent = element2.getProjectionParent();
        if (!projection.relativeTarget || !relativeParent)
          return;
        calcRelativeBox(projection, relativeParent.projection);
        if (isDraggable(relativeParent)) {
          var target = projection.target;
          applyBoxTransforms(target, target, relativeParent.getLatestValues());
        }
      },
      shouldResetTransform: function() {
        return Boolean(props._layoutResetTransform);
      },
      /**
       *
       */
      pointTo: function(newLead) {
        leadProjection = newLead.projection;
        leadLatestValues = newLead.getLatestValues();
        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();
        unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element2.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function() {
          var _a3;
          if (element2.isPresent) {
            element2.presence = Presence.Present;
          } else {
            (_a3 = element2.layoutSafeToRemove) === null || _a3 === void 0 ? void 0 : _a3.call(element2);
          }
        }));
      },
      // TODO: Clean this up
      isPresent: true,
      presence: Presence.Entering
    });
    return element2;
  };
};
function fireResolveRelativeTargetBox(child2) {
  child2.resolveRelativeTargetBox();
}
function fireUpdateLayoutProjection(child2) {
  child2.updateLayoutProjection();
}
var variantProps = __spreadArray7(["initial"], __read10(variantPriorityOrder));
var numVariantProps = variantProps.length;

// node_modules/svelte-motion/src/motion/utils/valid-prop.js
var validMotionProps = /* @__PURE__ */ new Set([
  "initial",
  "animate",
  "exit",
  "style",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "layout",
  "layoutId",
  "onLayoutAnimationComplete",
  "onViewportBoxUpdate",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "drag",
  "dragControls",
  "dragListener",
  "dragConstraints",
  "dragDirectionLock",
  "_dragX",
  "_dragY",
  "dragElastic",
  "dragMomentum",
  "dragPropagation",
  "dragTransition",
  "whileDrag",
  "onPan",
  "onPanStart",
  "onPanEnd",
  "onPanSessionStart",
  "onTap",
  "onTapStart",
  "onTapCancel",
  "onHoverStart",
  "onHoverEnd",
  "whileFocus",
  "whileTap",
  "whileHover"
]);
function isValidMotionProp(key) {
  return validMotionProps.has(key);
}

// node_modules/svelte-motion/src/context/PresenceContext.js
var PresenceContext = (c) => getDomContext("Presence", c) || writable(null);

// node_modules/svelte-motion/src/components/AnimatePresence/use-presence.js
var counter = 0;
var incrementId = () => counter++;
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
var useIsPresent = (isCustom = false) => {
  let presenceContext = getContext(PresenceContext) || PresenceContext(isCustom);
  return derived(presenceContext, ($v) => $v === null ? true : $v.isPresent);
};
var usePresence = (isCustom = false) => {
  const context = getContext(PresenceContext) || PresenceContext(isCustom);
  const id = get2(context) === null ? void 0 : incrementId();
  onMount(() => {
    if (get2(context) !== null) {
      get2(context).register(id);
    }
  });
  if (get2(context) === null) {
    return readable([true, null]);
  }
  return derived(
    context,
    ($v) => !$v.isPresent && $v.onExitComplete ? [false, () => {
      var _a;
      return (_a = $v.onExitComplete) == null ? void 0 : _a.call($v, id);
    }] : [true]
  );
};

// node_modules/svelte-motion/src/context/LayoutGroupContext.js
var LayoutGroupContext = (c) => getDomContext("LayoutGroup", c) || writable(null);

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/batcher.js
import { __spreadArray as __spreadArray8, __read as __read11 } from "tslib";
import sync5, { flushSync } from "framesync";

// node_modules/svelte-motion/src/render/dom/projection/utils.js
import sync3 from "framesync";
function isProjecting(visualElement2) {
  var isEnabled = visualElement2.projection.isEnabled;
  return isEnabled || visualElement2.shouldResetTransform();
}
function collectProjectingAncestors(visualElement2, ancestors) {
  if (ancestors === void 0) {
    ancestors = [];
  }
  var parent = visualElement2.parent;
  if (parent)
    collectProjectingAncestors(parent, ancestors);
  if (isProjecting(visualElement2))
    ancestors.push(visualElement2);
  return ancestors;
}
function collectProjectingChildren(visualElement2) {
  var children = [];
  var addChild = function(child2) {
    if (isProjecting(child2))
      children.push(child2);
    child2.children.forEach(addChild);
  };
  visualElement2.children.forEach(addChild);
  return children.sort(compareByDepth);
}
function updateLayoutMeasurement(visualElement2) {
  if (visualElement2.shouldResetTransform())
    return;
  var layoutState2 = visualElement2.getLayoutState();
  visualElement2.notifyBeforeLayoutMeasure(layoutState2.layout);
  layoutState2.isHydrated = true;
  layoutState2.layout = visualElement2.measureViewportBox();
  layoutState2.layoutCorrected = copyAxisBox(layoutState2.layout);
  visualElement2.notifyLayoutMeasure(layoutState2.layout, visualElement2.prevViewportBox || layoutState2.layout);
  sync3.update(function() {
    return visualElement2.rebaseProjectionTarget();
  });
}
function snapshotViewportBox(visualElement2, nc) {
  if (visualElement2.shouldResetTransform())
    return;
  if (!nc) visualElement2.prevViewportBox = visualElement2.measureViewportBox(false);
  visualElement2.rebaseProjectionTarget(false, visualElement2.prevViewportBox);
}

// node_modules/svelte-motion/src/render/dom/utils/batch-layout.js
import sync4 from "framesync";
var unresolvedJobs = /* @__PURE__ */ new Set();
var layoutState = {
  isMeasuringLayout: false
};
function pushJob(stack, job, pointer) {
  if (!stack[pointer])
    stack[pointer] = [];
  stack[pointer].push(job);
}
function batchLayout(callback) {
  unresolvedJobs.add(callback);
  return function() {
    return unresolvedJobs.delete(callback);
  };
}
function flushLayout() {
  if (!unresolvedJobs.size)
    return;
  var pointer = 0;
  var reads = [[]];
  var writes = [];
  var setRead = function(job) {
    return pushJob(reads, job, pointer);
  };
  var setWrite = function(job) {
    pushJob(writes, job, pointer);
    pointer++;
  };
  unresolvedJobs.forEach(function(callback) {
    callback(setRead, setWrite);
    pointer = 0;
  });
  unresolvedJobs.clear();
  layoutState.isMeasuringLayout = true;
  sync4.postRender(function() {
    setTimeout(function() {
      return layoutState.isMeasuringLayout = false;
    }, 10);
  });
  var numStacks = writes.length;
  for (var i = 0; i <= numStacks; i++) {
    reads[i] && reads[i].forEach(executeJob);
    writes[i] && writes[i].forEach(executeJob);
  }
}
var executeJob = function(job) {
  return job();
};

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/batcher.js
var defaultHandler = {
  layoutReady: function(child2) {
    return child2.notifyLayoutReady();
  }
};
function createBatcher() {
  var queue = /* @__PURE__ */ new Set();
  return {
    add: function(child2) {
      return queue.add(child2);
    },
    flush: function(_a) {
      var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;
      batchLayout(function(read, write) {
        var order2 = Array.from(queue).sort(compareByDepth);
        var ancestors = parent ? collectProjectingAncestors(parent) : [];
        write(function() {
          var allElements = __spreadArray8(__spreadArray8([], __read11(ancestors)), __read11(order2));
          allElements.forEach(function(element2) {
            return element2.resetTransform();
          });
        });
        read(function() {
          order2.forEach(updateLayoutMeasurement);
        });
        write(function() {
          ancestors.forEach(function(element2) {
            return element2.restoreTransform();
          });
          order2.forEach(layoutReady);
        });
        read(function() {
          order2.forEach(function(child2) {
            if (child2.isPresent)
              child2.presence = Presence.Present;
          });
        });
        write(function() {
          flushSync.preRender();
          flushSync.render();
        });
        read(function() {
          sync5.postRender(function() {
            return order2.forEach(assignProjectionToSnapshot);
          });
          queue.clear();
        });
      });
      flushLayout();
    }
  };
}
function assignProjectionToSnapshot(child2) {
  child2.prevViewportBox = child2.projection.target;
}

// node_modules/svelte-motion/src/context/SharedLayoutContext.js
var SharedLayoutContext = (custom) => getDomContext("SharedLayout", custom) || writable(createBatcher());
var FramerTreeLayoutContext = () => writable(createBatcher());
function isSharedLayout(context) {
  return !!context.forceUpdate;
}

// node_modules/svelte-motion/src/context/LazyContext.js
var LazyContext = (c) => getDomContext("Lazy", c) || writable({ strict: false });

// node_modules/svelte-motion/src/context/MotionContext/MotionContext.svelte
mark_module_start();
MotionContext_1[FILENAME] = "node_modules/svelte-motion/src/context/MotionContext/MotionContext.svelte";
var MotionContext = (c) => getDomContext("Motion", c) || writable({});
function MotionContext_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, MotionContext_1);
  const [$$stores, $$cleanup] = setup_stores();
  const $motionContext = () => (validate_store(motionContext, "motionContext"), store_get(motionContext, "$motionContext", $$stores));
  let isCustom = prop($$props, "isCustom", 8);
  const motionContext = getContext(MotionContext) || MotionContext(isCustom());
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    $$props,
    "default",
    {
      get parent() {
        return $motionContext().visualElement;
      }
    },
    null
  );
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  MotionContext_1 = hmr(MotionContext_1, () => MotionContext_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MotionContext_1[HMR].source;
    set(MotionContext_1[HMR].source, module.default[HMR].original);
  });
}
mark_module_end(MotionContext_1);

// node_modules/svelte-motion/src/motion/utils/UseVisualElement.svelte
mark_module_start();
UseVisualElement[FILENAME] = "node_modules/svelte-motion/src/motion/utils/UseVisualElement.svelte";
function UseVisualElement($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseVisualElement);
  const [$$stores, $$cleanup] = setup_stores();
  const $mc = () => (validate_store(mc, "mc"), store_get(mc, "$mc", $$stores));
  const $layoutGroupId = () => (validate_store(layoutGroupId, "layoutGroupId"), store_get(layoutGroupId, "$layoutGroupId", $$stores));
  const $lazyContext = () => (validate_store(lazyContext, "lazyContext"), store_get(lazyContext, "$lazyContext", $$stores));
  const $presenceContext = () => (validate_store(presenceContext, "presenceContext"), store_get(presenceContext, "$presenceContext", $$stores));
  const $config = () => (validate_store(config, "config"), store_get(config, "$config", $$stores));
  let createVisualElement = prop($$props, "createVisualElement", 12, void 0), props = prop($$props, "props", 8), Component = prop($$props, "Component", 8), visualState = prop($$props, "visualState", 8), isCustom = prop($$props, "isCustom", 8);
  const config = getContext(MotionConfigContext) || MotionConfigContext(isCustom());
  const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom());
  const lazyContext = getContext(LazyContext) || LazyContext(isCustom());
  const mc = getContext(MotionContext) || MotionContext(isCustom());
  let parent = mutable_source(get2(mc).visualElement);
  const layoutGroupId = getContext(LayoutGroupContext) || LayoutGroupContext(isCustom());
  let layoutId = mutable_source($layoutGroupId() && strict_equals(props().layoutId, void 0, false) ? $layoutGroupId() + "-" + props().layoutId : props().layoutId);
  let visualElementRef = mutable_source(void 0);
  if (!createVisualElement()) {
    createVisualElement($lazyContext().renderer);
  }
  let visualElement2 = mutable_source(get(visualElementRef));
  afterUpdate(() => {
    tick().then(() => {
      var _a;
      (_a = get(visualElement2).animationState) == null ? void 0 : _a.animateChanges();
    });
  });
  onDestroy(() => {
    var _a;
    (_a = get(visualElement2)) == null ? void 0 : _a.notifyUnmount();
  });
  legacy_pre_effect(() => $mc(), () => {
    set(parent, $mc().visualElement);
  });
  legacy_pre_effect(
    () => ($layoutGroupId(), deep_read_state(props())),
    () => {
      set(layoutId, $layoutGroupId() && strict_equals(props().layoutId, void 0, false) ? $layoutGroupId() + "-" + props().layoutId : props().layoutId);
    }
  );
  legacy_pre_effect(
    () => (get(visualElementRef), deep_read_state(createVisualElement()), deep_read_state(Component()), deep_read_state(visualState()), get(parent), deep_read_state(props()), get(layoutId), $presenceContext()),
    () => {
      var _a, _b;
      if (!get(visualElementRef) && createVisualElement()) {
        set(visualElementRef, createVisualElement()(Component(), {
          visualState: visualState(),
          parent: get(parent),
          props: { ...props(), layoutId: get(layoutId) },
          presenceId: (_a = $presenceContext()) == null ? void 0 : _a.id,
          blockInitialAnimation: strict_equals((_b = $presenceContext()) == null ? void 0 : _b.initial, false)
        }));
      }
    }
  );
  legacy_pre_effect(() => get(visualElementRef), () => {
    set(visualElement2, get(visualElementRef));
  });
  legacy_pre_effect(
    () => (get(visualElement2), $config(), deep_read_state(props()), get(layoutId), isPresent, $presenceContext(), get(parent)),
    () => {
      var _a;
      if (get(visualElement2)) {
        get(visualElement2).setProps({
          ...$config(),
          ...props(),
          layoutId: get(layoutId)
        });
        mutate(visualElement2, get(visualElement2).isPresent = isPresent($presenceContext()));
        mutate(visualElement2, get(visualElement2).isPresenceRoot = !get(parent) || strict_equals(get(parent).presenceId, (_a = $presenceContext()) == null ? void 0 : _a.id, false));
        get(visualElement2).syncRender();
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    $$props,
    "default",
    {
      get visualElement() {
        return get(visualElement2);
      }
    },
    null
  );
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  UseVisualElement = hmr(UseVisualElement, () => UseVisualElement[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseVisualElement[HMR].source;
    set(UseVisualElement[HMR].source, module.default[HMR].original);
  });
}
var UseVisualElement_default = UseVisualElement;
mark_module_end(UseVisualElement);

// node_modules/svelte-motion/src/motion/features/definitions.js
var createDefinition = function(propNames) {
  return {
    isEnabled: function(props) {
      return propNames.some(function(name) {
        return !!props[name];
      });
    }
  };
};
var featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  layoutAnimation: createDefinition(["layout", "layoutId"])
};
function loadFeatures(features) {
  for (var key in features) {
    var Component = features[key];
    if (Component !== null) {
      featureDefinitions[key].Component = Component;
    }
  }
}

// node_modules/svelte-motion/src/motion/features/UseFeatures.svelte
mark_module_start();
UseFeatures[FILENAME] = "node_modules/svelte-motion/src/motion/features/UseFeatures.svelte";
function UseFeatures($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseFeatures);
  const featureNames = Object.keys(featureDefinitions);
  const numFeatures = featureNames.length;
  let visualElement2 = prop($$props, "visualElement", 8), props = prop($$props, "props", 8);
  let features = mutable_source([]);
  legacy_pre_effect(
    () => (get(features), featureDefinitions, deep_read_state(props()), deep_read_state(visualElement2())),
    () => {
      set(features, []);
      for (let i = 0; i < numFeatures; i++) {
        const name = featureNames[i];
        const { isEnabled, Component } = featureDefinitions[name];
        if (isEnabled(props()) && Component) {
          get(features).push({
            Component,
            key: name,
            props: props(),
            visualElement: visualElement2()
          });
        }
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(
        node_1,
        $$props,
        "default",
        {
          get features() {
            return get(features);
          }
        },
        null
      );
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (visualElement2()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseFeatures = hmr(UseFeatures, () => UseFeatures[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseFeatures[HMR].source;
    set(UseFeatures[HMR].source, module.default[HMR].original);
  });
}
var UseFeatures_default = UseFeatures;
mark_module_end(UseFeatures);

// node_modules/svelte-motion/src/context/MotionContext/MotionContextProvider.svelte
mark_module_start();
MotionContextProvider[FILENAME] = "node_modules/svelte-motion/src/context/MotionContext/MotionContextProvider.svelte";
function MotionContextProvider($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, MotionContextProvider);
  let value = prop($$props, "value", 8), isCustom = prop($$props, "isCustom", 8);
  let store = writable(value());
  setContext(MotionContext, store);
  setDomContext("Motion", isCustom(), store);
  onDestroy(() => {
    var _a, _b;
    (_b = (_a = value()) == null ? void 0 : _a.visualElement) == null ? void 0 : _b.unmount();
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    store.set(value());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MotionContextProvider = hmr(MotionContextProvider, () => MotionContextProvider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MotionContextProvider[HMR].source;
    set(MotionContextProvider[HMR].source, module.default[HMR].original);
  });
}
var MotionContextProvider_default = MotionContextProvider;
mark_module_end(MotionContextProvider);

// node_modules/svelte-motion/src/render/html/utils/create-render-state.js
var createHtmlRenderState = function() {
  return {
    style: {},
    transform: {},
    transformKeys: [],
    transformOrigin: {},
    vars: {}
  };
};

// node_modules/svelte-motion/src/render/svg/utils/create-render-state.js
var createSvgRenderState = function() {
  return Object.assign(Object.assign({}, createHtmlRenderState()), { attrs: {} });
};

// node_modules/svelte-motion/src/render/html/utils/transform.js
var transformAxes = ["", "X", "Y", "Z"];
var order = ["translate", "scale", "rotate", "skew"];
var transformProps = ["transformPerspective", "x", "y", "z"];
order.forEach(function(operationKey) {
  return transformAxes.forEach(function(axesKey) {
    return transformProps.push(operationKey + axesKey);
  });
});
function sortTransformProps(a, b) {
  return transformProps.indexOf(a) - transformProps.indexOf(b);
}
var transformPropSet = new Set(transformProps);
function isTransformProp(key) {
  return transformPropSet.has(key);
}
var transformOriginProps = /* @__PURE__ */ new Set(["originX", "originY", "originZ"]);
function isTransformOriginProp(key) {
  return transformOriginProps.has(key);
}

// node_modules/svelte-motion/src/motion/utils/is-forced-motion-value.js
function isForcedMotionValue(key, _a) {
  var layout = _a.layout, layoutId = _a.layoutId;
  return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== void 0) && !!valueScaleCorrection[key];
}

// node_modules/svelte-motion/src/render/html/utils/build-transform.js
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
function buildTransform(_a, _b, transformIsDefault, transformTemplate) {
  var transform2 = _a.transform, transformKeys2 = _a.transformKeys;
  var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;
  var transformString = "";
  transformKeys2.sort(sortTransformProps);
  var transformHasZ = false;
  var numTransformKeys = transformKeys2.length;
  for (var i = 0; i < numTransformKeys; i++) {
    var key = transformKeys2[i];
    transformString += (translateAlias[key] || key) + "(" + transform2[key] + ") ";
    if (key === "z")
      transformHasZ = true;
  }
  if (!transformHasZ && enableHardwareAcceleration) {
    transformString += "translateZ(0)";
  } else {
    transformString = transformString.trim();
  }
  if (transformTemplate) {
    transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildTransformOrigin(_a) {
  var _b = _a.originX, originX = _b === void 0 ? "50%" : _b, _c = _a.originY, originY = _c === void 0 ? "50%" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;
  return originX + " " + originY + " " + originZ;
}

// node_modules/svelte-motion/src/render/dom/utils/is-css-variable.js
function isCSSVariable(key) {
  return key.startsWith("--");
}

// node_modules/svelte-motion/src/render/dom/value-types/get-as-type.js
var getValueAsType = function(value, type) {
  return type && typeof value === "number" ? type.transform(value) : value;
};

// node_modules/svelte-motion/src/render/html/utils/build-styles.js
function buildHTMLStyles(state, latestValues, projection, layoutState2, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {
  var _a;
  var style = state.style, vars = state.vars, transform2 = state.transform, transformKeys2 = state.transformKeys, transformOrigin = state.transformOrigin;
  transformKeys2.length = 0;
  var hasTransform = false;
  var hasTransformOrigin = false;
  var transformIsNone = true;
  for (var key in latestValues) {
    var value = latestValues[key];
    if (isCSSVariable(key)) {
      vars[key] = value;
      continue;
    }
    var valueType = numberValueTypes[key];
    var valueAsType = getValueAsType(value, valueType);
    if (isTransformProp(key)) {
      hasTransform = true;
      transform2[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))
        transformIsNone = false;
    } else if (isTransformOriginProp(key)) {
      transformOrigin[key] = valueAsType;
      hasTransformOrigin = true;
    } else {
      if (layoutState2 && projection && layoutState2.isHydrated && valueScaleCorrection[key]) {
        var correctedValue = valueScaleCorrection[key].process(value, layoutState2, projection);
        var applyTo = valueScaleCorrection[key].applyTo;
        if (applyTo) {
          var num = applyTo.length;
          for (var i = 0; i < num; i++) {
            style[applyTo[i]] = correctedValue;
          }
        } else {
          style[key] = correctedValue;
        }
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (layoutState2 && projection && buildProjectionTransform && buildProjectionTransformOrigin) {
    style.transform = buildProjectionTransform(layoutState2.deltaFinal, layoutState2.treeScale, hasTransform ? transform2 : void 0);
    if (transformTemplate) {
      style.transform = transformTemplate(transform2, style.transform);
    }
    style.transformOrigin = buildProjectionTransformOrigin(layoutState2);
  } else {
    if (hasTransform) {
      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);
    }
    if (hasTransformOrigin) {
      style.transformOrigin = buildTransformOrigin(transformOrigin);
    }
  }
}

// node_modules/svelte-motion/src/render/html/UseInitialMotionValues.svelte
mark_module_start();
UseInitialMotionValues[FILENAME] = "node_modules/svelte-motion/src/render/html/UseInitialMotionValues.svelte";
function UseInitialMotionValues($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseInitialMotionValues);
  const styles = mutable_source();
  let visualState = prop($$props, "visualState", 8), isStatic = prop($$props, "isStatic", 8), props = prop($$props, "props", 8);
  const memo = () => {
    let state = createHtmlRenderState();
    buildHTMLStyles(state, visualState(), void 0, void 0, { enableHardwareAcceleration: !isStatic() }, props().transformTemplate);
    const { vars, style } = state;
    return { ...vars, ...style };
  };
  legacy_pre_effect(() => deep_read_state(visualState()), () => {
    set(styles, memo(visualState()));
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    $$props,
    "default",
    {
      get styles() {
        return get(styles);
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseInitialMotionValues = hmr(UseInitialMotionValues, () => UseInitialMotionValues[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseInitialMotionValues[HMR].source;
    set(UseInitialMotionValues[HMR].source, module.default[HMR].original);
  });
}
var UseInitialMotionValues_default = UseInitialMotionValues;
mark_module_end(UseInitialMotionValues);

// node_modules/svelte-motion/src/render/html/UseStyle.svelte
mark_module_start();
UseStyle[FILENAME] = "node_modules/svelte-motion/src/render/html/UseStyle.svelte";
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function UseStyle($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseStyle);
  const styleProp = mutable_source();
  let visualState = prop($$props, "visualState", 8), props = prop($$props, "props", 8), isStatic = prop($$props, "isStatic", 8);
  let style = mutable_source({});
  const cRVO = copyRawValuesOnly;
  const toStyle = (s1) => {
    Object.assign(get(style), s1);
    if (props().transformValues) {
      set(style, props().transformValues(get(style)));
    }
    return get(style);
  };
  legacy_pre_effect(() => deep_read_state(props()), () => {
    set(styleProp, props().style || {});
  });
  legacy_pre_effect(
    () => (get(style), get(styleProp), deep_read_state(props())),
    () => {
      cRVO(get(style), get(styleProp), props());
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  UseInitialMotionValues_default(node, {
    get props() {
      return props();
    },
    get visualState() {
      return visualState();
    },
    get isStatic() {
      return isStatic();
    },
    children: invalid_default_snippet,
    $$slots: {
      default: ($$anchor2, $$slotProps) => {
        const s1 = derived_safe_equal(() => $$slotProps.styles);
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        const expression = derived_safe_equal(() => toStyle(get(s1), props(), get(style)));
        slot(
          node_1,
          $$props,
          "default",
          {
            get styles() {
              return get(expression);
            }
          },
          null
        );
        append($$anchor2, fragment_1);
      }
    }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseStyle = hmr(UseStyle, () => UseStyle[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseStyle[HMR].source;
    set(UseStyle[HMR].source, module.default[HMR].original);
  });
}
var UseStyle_default = UseStyle;
mark_module_end(UseStyle);

// node_modules/svelte-motion/src/render/html/UseHTMLProps.svelte
mark_module_start();
UseHTMLProps[FILENAME] = "node_modules/svelte-motion/src/render/html/UseHTMLProps.svelte";
function UseHTMLProps($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseHTMLProps);
  let props = prop($$props, "props", 8), visualState = prop($$props, "visualState", 8), isStatic = prop($$props, "isStatic", 8);
  const getHTMLProps = (style, props2) => {
    let htmlProps = {};
    if (Boolean(props2.drag)) {
      htmlProps.draggable = false;
      style.userSelect = assign(style, "WebkitUserSelect", assign(style, "WebkitTouchCallout", "none", "node_modules/svelte-motion/src/render/html/UseHTMLProps.svelte:21:56"), "node_modules/svelte-motion/src/render/html/UseHTMLProps.svelte:21:31");
      style.touchAction = strict_equals(props2.drag, true) ? "none" : `pan-${strict_equals(props2.drag, "x") ? "y" : "x"}`;
    }
    htmlProps.style = style;
    return htmlProps;
  };
  var fragment = comment();
  var node = first_child(fragment);
  UseStyle_default(node, {
    get visualState() {
      return visualState();
    },
    get props() {
      return props();
    },
    get isStatic() {
      return isStatic();
    },
    children: invalid_default_snippet,
    $$slots: {
      default: ($$anchor2, $$slotProps) => {
        const styles = derived_safe_equal(() => $$slotProps.styles);
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        const expression = derived_safe_equal(() => getHTMLProps(get(styles), props()));
        slot(
          node_1,
          $$props,
          "default",
          {
            get visualProps() {
              return get(expression);
            }
          },
          null
        );
        append($$anchor2, fragment_1);
      }
    }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseHTMLProps = hmr(UseHTMLProps, () => UseHTMLProps[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseHTMLProps[HMR].source;
    set(UseHTMLProps[HMR].source, module.default[HMR].original);
  });
}
var UseHTMLProps_default = UseHTMLProps;
mark_module_end(UseHTMLProps);

// node_modules/svelte-motion/src/render/svg/utils/build-attrs.js
import { __rest as __rest5 } from "tslib";

// node_modules/svelte-motion/src/render/svg/utils/transform-origin.js
import { px as px3 } from "style-value-types";
function calcOrigin2(origin, offset, size) {
  return typeof origin === "string" ? origin : px3.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  var pxOriginX = calcOrigin2(originX, dimensions.x, dimensions.width);
  var pxOriginY = calcOrigin2(originY, dimensions.y, dimensions.height);
  return pxOriginX + " " + pxOriginY;
}

// node_modules/svelte-motion/src/render/svg/utils/path.js
import { px as px4 } from "style-value-types";
var progressToPixels = function(progress4, length) {
  return px4.transform(progress4 * length);
};
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {
  if (spacing === void 0) {
    spacing = 1;
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (useDashCase === void 0) {
    useDashCase = true;
  }
  var keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = progressToPixels(-offset, totalLength);
  var pathLength = progressToPixels(length, totalLength);
  var pathSpacing = progressToPixels(spacing, totalLength);
  attrs[keys.array] = pathLength + " " + pathSpacing;
}

// node_modules/svelte-motion/src/render/svg/utils/build-attrs.js
function buildSVGAttrs(state, _a, projection, layoutState2, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {
  var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, latest = __rest5(_a, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
  buildHTMLStyles(state, latest, projection, layoutState2, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);
  state.attrs = state.style;
  state.style = {};
  var attrs = state.attrs, style = state.style, dimensions = state.dimensions, totalPathLength = state.totalPathLength;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (totalPathLength !== void 0 && pathLength !== void 0) {
    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);
  }
}

// node_modules/svelte-motion/src/render/svg/UseSVGProps.svelte
mark_module_start();
UseSVGProps[FILENAME] = "node_modules/svelte-motion/src/render/svg/UseSVGProps.svelte";
function UseSVGProps($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseSVGProps);
  const visualProps = mutable_source();
  let visualState = prop($$props, "visualState", 8), props = prop($$props, "props", 8);
  let memo = () => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState(), void 0, void 0, { enableHardwareAcceleration: false }, props().transformTemplate);
    return { ...state.attrs, style: { ...state.style } };
  };
  legacy_pre_effect(() => deep_read_state(visualState()), () => {
    set(visualProps, memo(visualState()));
  });
  legacy_pre_effect(
    () => (deep_read_state(props()), copyRawValuesOnly, get(visualProps)),
    () => {
      if (props().style) {
        const rawStyles = {};
        copyRawValuesOnly(rawStyles, props().style, props());
        mutate(visualProps, get(visualProps).style = { ...rawStyles, ...get(visualProps).style });
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    $$props,
    "default",
    {
      get visualProps() {
        return get(visualProps);
      }
    },
    null
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseSVGProps = hmr(UseSVGProps, () => UseSVGProps[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseSVGProps[HMR].source;
    set(UseSVGProps[HMR].source, module.default[HMR].original);
  });
}
var UseSVGProps_default = UseSVGProps;
mark_module_end(UseSVGProps);

// node_modules/svelte-motion/src/render/dom/utils/filter-props.js
var shouldForward = function(key) {
  return !isValidMotionProp(key);
};
try {
  emotionIsPropValid_1 = __require("@emotion/is-prop-valid").default;
  shouldForward = function(key) {
    if (key.startsWith("on")) {
      return !isValidMotionProp(key);
    } else {
      return emotionIsPropValid_1(key);
    }
  };
} catch (_a) {
}
var emotionIsPropValid_1;
function filterProps(props, isDom, forwardMotionProps) {
  var filteredProps = {};
  for (var key in props) {
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key)) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}

// node_modules/svelte-motion/src/render/dom/UseRender.svelte
mark_module_start();
UseRender[FILENAME] = "node_modules/svelte-motion/src/render/dom/UseRender.svelte";
function UseRender($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseRender);
  const filteredProps = mutable_source();
  let props = prop($$props, "props", 8), visualState = prop($$props, "visualState", 8), Component = prop($$props, "Component", 8), forwardMotionProps = prop($$props, "forwardMotionProps", 8, false), isStatic = prop($$props, "isStatic", 8), ref = prop($$props, "ref", 8), targetEl = prop($$props, "targetEl", 8, void 0);
  const motion2 = (node) => {
    ref()(node);
  };
  legacy_pre_effect(
    () => (filterProps, deep_read_state(props()), deep_read_state(Component()), deep_read_state(forwardMotionProps())),
    () => {
      set(filteredProps, filterProps(props(), strict_equals(typeof Component(), "string"), forwardMotionProps()));
    }
  );
  legacy_pre_effect(() => deep_read_state(targetEl()), () => {
    if (targetEl()) {
      motion2(targetEl());
    }
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node_1 = first_child(fragment);
  component(node_1, () => strict_equals(Component(), "SVG") ? UseSVGProps_default : UseHTMLProps_default, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      get visualState() {
        return visualState();
      },
      get isStatic() {
        return isStatic();
      },
      get props() {
        return props();
      },
      children: invalid_default_snippet,
      $$slots: {
        default: ($$anchor3, $$slotProps) => {
          const visualProps = derived_safe_equal(() => $$slotProps.visualProps);
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          const expression = derived_safe_equal(() => ({
            ...get(filteredProps),
            ...get(visualProps)
          }));
          slot(
            node_2,
            $$props,
            "default",
            {
              motion: motion2,
              get props() {
                return get(expression);
              }
            },
            null
          );
          append($$anchor3, fragment_1);
        }
      }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseRender = hmr(UseRender, () => UseRender[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseRender[HMR].source;
    set(UseRender[HMR].source, module.default[HMR].original);
  });
}
var UseRender_default = UseRender;
mark_module_end(UseRender);

// node_modules/svelte-motion/src/render/html/visual-element.js
import { __rest as __rest7 } from "tslib";

// node_modules/svelte-motion/src/render/dom/projection/measure.js
function getBoundingBox(element2, transformPagePoint) {
  var box = element2.getBoundingClientRect();
  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));
}

// node_modules/svelte-motion/src/render/dom/utils/css-variables-conversion.js
import { __rest as __rest6, __read as __read12 } from "tslib";
function isCSSVariable2(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  var match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  var _a = __read12(match, 3), token = _a[1], fallback = _a[2];
  return [token, fallback];
}
function getVariableValue(current, element2, depth) {
  if (depth === void 0) {
    depth = 1;
  }
  var _a = __read12(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];
  if (!token)
    return;
  var resolved = window.getComputedStyle(element2).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable2(fallback)) {
    return getVariableValue(fallback, element2, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement2, _a, transitionEnd) {
  var _b;
  var target = __rest6(_a, []);
  var element2 = visualElement2.getInstance();
  if (!(element2 instanceof HTMLElement))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = Object.assign({}, transitionEnd);
  }
  visualElement2.forEachValue(function(value) {
    var current2 = value.get();
    if (!isCSSVariable2(current2))
      return;
    var resolved2 = getVariableValue(current2, element2);
    if (resolved2)
      value.set(resolved2);
  });
  for (var key in target) {
    var current = target[key];
    if (!isCSSVariable2(current))
      continue;
    var resolved = getVariableValue(current, element2);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (transitionEnd)
      (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;
  }
  return { target, transitionEnd };
}

// node_modules/svelte-motion/src/render/dom/utils/unit-conversion.js
import { __read as __read13 } from "tslib";
import { number as number3, px as px5 } from "style-value-types";
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
var isPositionalKey = function(key) {
  return positionalKeys.has(key);
};
var hasPositionalKey = function(target) {
  return Object.keys(target).some(isPositionalKey);
};
var setAndResetVelocity = function(value, to) {
  value.set(to, false);
  value.set(to);
};
var isNumOrPxType = function(v) {
  return v === number3 || v === px5;
};
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
var getPosFromMatrix = function(matrix, pos) {
  return parseFloat(matrix.split(", ")[pos]);
};
var getTranslateFromMatrix = function(pos2, pos3) {
  return function(_bbox, _a) {
    var transform2 = _a.transform;
    if (transform2 === "none" || !transform2)
      return 0;
    var matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      var matrix = transform2.match(/^matrix\((.+)\)$/);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
};
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformProps.filter(function(key) {
  return !transformKeys.has(key);
});
function removeNonTranslationalTransform(visualElement2) {
  var removedTransforms = [];
  nonTranslationalTransformKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement2.syncRender();
  return removedTransforms;
}
var positionalValues = {
  // Dimensions
  width: function(_a) {
    var x = _a.x;
    return x.max - x.min;
  },
  height: function(_a) {
    var y = _a.y;
    return y.max - y.min;
  },
  top: function(_bbox, _a) {
    var top = _a.top;
    return parseFloat(top);
  },
  left: function(_bbox, _a) {
    var left = _a.left;
    return parseFloat(left);
  },
  bottom: function(_a, _b) {
    var y = _a.y;
    var top = _b.top;
    return parseFloat(top) + (y.max - y.min);
  },
  right: function(_a, _b) {
    var x = _a.x;
    var left = _b.left;
    return parseFloat(left) + (x.max - x.min);
  },
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
var convertChangedValueTypes = function(target, visualElement2, changedKeys) {
  var originBbox = visualElement2.measureViewportBox();
  var element2 = visualElement2.getInstance();
  var elementComputedStyle = getComputedStyle(element2);
  var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform2 = elementComputedStyle.transform;
  var originComputedStyle = { top, left, bottom, right, transform: transform2 };
  if (display === "none") {
    visualElement2.setStaticValue("display", target.display || "block");
  }
  visualElement2.syncRender();
  var targetBbox = visualElement2.measureViewportBox();
  changedKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
var checkAndConvertChangedValueTypes = function(visualElement2, target, origin, transitionEnd) {
  if (origin === void 0) {
    origin = {};
  }
  if (transitionEnd === void 0) {
    transitionEnd = {};
  }
  target = Object.assign({}, target);
  transitionEnd = Object.assign({}, transitionEnd);
  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  var removedTransformValues = [];
  var hasAttemptedToRemoveTransformValues = false;
  var changedValueTypeKeys = [];
  targetPositionalKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (!visualElement2.hasValue(key))
      return;
    var from = origin[key];
    var to = target[key];
    var fromType = findDimensionValueType(from);
    var toType;
    if (isKeyframesTarget(to)) {
      var numKeyframes = to.length;
      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {
        if (!toType) {
          toType = findDimensionValueType(to[i]);
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        var current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px5) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement2);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        setAndResetVelocity(value, to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    var convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(function(_a) {
        var _b = __read13(_a, 2), key = _b[0], value = _b[1];
        visualElement2.getValue(key).set(value);
      });
    }
    visualElement2.syncRender();
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement2, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin, transitionEnd) : { target, transitionEnd };
}

// node_modules/svelte-motion/src/render/dom/utils/parse-dom-variant.js
var parseDomVariant = function(visualElement2, target, origin, transitionEnd) {
  var resolved = resolveCSSVariables(visualElement2, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement2, target, origin, transitionEnd);
};

// node_modules/svelte-motion/src/render/html/utils/scrape-motion-values.js
function scrapeMotionValuesFromProps(props) {
  var style = props.style;
  var newValues = {};
  for (var key in style) {
    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}

// node_modules/svelte-motion/src/render/html/utils/render.js
function renderHTML(element2, _a) {
  var style = _a.style, vars = _a.vars;
  Object.assign(element2.style, style);
  for (var key in vars) {
    element2.style.setProperty(key, vars[key]);
  }
}

// node_modules/svelte-motion/src/render/html/visual-element.js
function getComputedStyle2(element2) {
  return window.getComputedStyle(element2);
}
var htmlConfig = {
  treeType: "dom",
  readValueFromInstance: function(domElement, key) {
    if (isTransformProp(key)) {
      var defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      var computedStyle = getComputedStyle2(domElement);
      return (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
    }
  },
  sortNodePosition: function(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  },
  getBaseTarget: function(props, key) {
    var _a;
    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];
  },
  measureViewportBox: function(element2, _a) {
    var transformPagePoint = _a.transformPagePoint;
    return getBoundingBox(element2, transformPagePoint);
  },
  /**
   * Reset the transform on the current Element. This is called as part
   * of a batched process across the entire layout tree. To remove this write
   * cycle it'd be interesting to see if it's possible to "undo" all the current
   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms
   * works
   */
  resetTransform: function(element2, domElement, props) {
    var transformTemplate = props.transformTemplate;
    domElement.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    element2.scheduleRender();
  },
  restoreTransform: function(instance, mutableState) {
    instance.style.transform = mutableState.style.transform;
  },
  removeValueFromRenderState: function(key, _a) {
    var vars = _a.vars, style = _a.style;
    delete vars[key];
    delete style[key];
  },
  /**
   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`
   * can be animated by Motion.
   */
  makeTargetAnimatable: function(element2, _a, _b, isMounted) {
    var transformValues = _b.transformValues;
    if (isMounted === void 0) {
      isMounted = true;
    }
    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest7(_a, ["transition", "transitionEnd"]);
    var origin = getOrigin(target, transition || {}, element2);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(element2, target, origin);
      var parsed = parseDomVariant(element2, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return Object.assign({
      transition,
      transitionEnd
    }, target);
  },
  scrapeMotionValuesFromProps,
  build: function(element2, renderState, latestValues, projection, layoutState2, options, props) {
    if (element2.isVisible !== void 0) {
      renderState.style.visibility = element2.isVisible ? "visible" : "hidden";
    }
    var isProjectionTranform = projection.isEnabled && layoutState2.isHydrated;
    buildHTMLStyles(renderState, latestValues, projection, layoutState2, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : void 0, isProjectionTranform ? buildLayoutProjectionTransformOrigin : void 0);
  },
  render: renderHTML
};
var htmlVisualElement = visualElement(htmlConfig);

// node_modules/svelte-motion/src/render/svg/utils/scrape-motion-values.js
function scrapeMotionValuesFromProps2(props) {
  var newValues = scrapeMotionValuesFromProps(props);
  for (var key in props) {
    if (isMotionValue(props[key])) {
      var targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}

// node_modules/svelte-motion/src/render/dom/utils/camel-to-dash.js
var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = "$1-$2";
var camelToDash = function(str) {
  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};

// node_modules/svelte-motion/src/render/svg/utils/camel-case-attrs.js
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox"
]);

// node_modules/svelte-motion/src/render/svg/utils/render.js
function renderSVG(element2, renderState) {
  renderHTML(element2, renderState);
  for (var key in renderState.attrs) {
    element2.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}

// node_modules/svelte-motion/src/render/svg/visual-element.js
var svgVisualElement = visualElement(Object.assign(Object.assign({}, htmlConfig), {
  getBaseTarget: function(props, key) {
    return props[key];
  },
  readValueFromInstance: function(domElement, key) {
    var _a;
    if (isTransformProp(key)) {
      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return domElement.getAttribute(key);
  },
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
  build: function(_element, renderState, latestValues, projection, layoutState2, options, props) {
    var isProjectionTranform = projection.isEnabled && layoutState2.isHydrated;
    buildSVGAttrs(renderState, latestValues, projection, layoutState2, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : void 0, isProjectionTranform ? buildLayoutProjectionTransformOrigin : void 0);
  },
  render: renderSVG
}));

// node_modules/svelte-motion/src/render/dom/create-visual-element.js
var createDomVisualElement = function(Component, options) {
  return Component === "SVG" ? svgVisualElement(options, { enableHardwareAcceleration: false }) : htmlVisualElement(options, { enableHardwareAcceleration: true });
};

// node_modules/svelte-motion/src/render/svg/config-motion.js
var svgMotionConfig = {
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
  createRenderState: createSvgRenderState,
  onMount: function(props, instance, _a) {
    var renderState = _a.renderState, latestValues = _a.latestValues;
    try {
      renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
    } catch (e) {
      renderState.dimensions = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
    if (isPath(instance)) {
      renderState.totalPathLength = instance.getTotalLength();
    }
    buildSVGAttrs(renderState, latestValues, void 0, void 0, { enableHardwareAcceleration: false }, props.transformTemplate);
    renderSVG(instance, renderState);
  }
};
function isPath(element2) {
  return element2.tagName === "path";
}

// node_modules/svelte-motion/src/render/html/config-motion.js
var htmlMotionConfig = {
  scrapeMotionValuesFromProps,
  createRenderState: createHtmlRenderState
};

// node_modules/svelte-motion/src/context/MotionContext/utils.js
function getCurrentTreeVariants(props, context) {
  if (checkIfControllingVariants(props)) {
    var initial = props.initial, animate4 = props.animate;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate4) ? animate4 : void 0
    };
  }
  return props.inherit !== false ? context || {} : {};
}

// node_modules/svelte-motion/src/context/MotionContext/UseCreateMotionContext.svelte
mark_module_start();
UseCreateMotionContext[FILENAME] = "node_modules/svelte-motion/src/context/MotionContext/UseCreateMotionContext.svelte";
function UseCreateMotionContext($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseCreateMotionContext);
  const [$$stores, $$cleanup] = setup_stores();
  const $mc = () => (validate_store(mc, "mc"), store_get(mc, "$mc", $$stores));
  let props = prop($$props, "props", 8), isStatic = prop($$props, "isStatic", 8), isCustom = prop($$props, "isCustom", 8);
  let mc = getContext(MotionContext) || MotionContext(isCustom());
  let tmp = getCurrentTreeVariants(props(), get2(mc)), initial = mutable_source(tmp.initial), animate4 = mutable_source(tmp.animate);
  const variantLabelsAsDependency = (prop2) => {
    return Array.isArray(prop2) ? prop2.join(" ") : prop2;
  };
  const memo = () => {
    return {
      initial: get(initial),
      animate: get(animate4)
    };
  };
  let value = mutable_source(memo());
  legacy_pre_effect(
    () => (get(initial), get(animate4), getCurrentTreeVariants, deep_read_state(props()), $mc()),
    () => {
      (($$value) => (set(initial, $$value.initial), set(animate4, $$value.animate)))(getCurrentTreeVariants(props(), $mc()));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(isStatic()), get(initial), get(animate4)),
    () => {
      if (isStatic()) {
        set(value, memo(variantLabelsAsDependency(get(initial)), variantLabelsAsDependency(get(animate4))));
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    $$props,
    "default",
    {
      get value() {
        return get(value);
      }
    },
    null
  );
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  UseCreateMotionContext = hmr(UseCreateMotionContext, () => UseCreateMotionContext[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseCreateMotionContext[HMR].source;
    set(UseCreateMotionContext[HMR].source, module.default[HMR].original);
  });
}
var UseCreateMotionContext_default = UseCreateMotionContext;
mark_module_end(UseCreateMotionContext);

// node_modules/svelte-motion/src/value/utils/resolve-motion-value.js
function resolveMotionValue(value) {
  var unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}

// node_modules/svelte-motion/src/motion/utils/UseVisualState.svelte
mark_module_start();
UseVisualState[FILENAME] = "node_modules/svelte-motion/src/motion/utils/UseVisualState.svelte";
var makeState = ({
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3,
  createRenderState,
  onMount: onMount2
}, props, context, presenceContext) => {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onMount2) {
    state.mount = (instance) => onMount2(props, instance, state);
  }
  return state;
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const blockInitialAnimation = strict_equals(presenceContext == null ? void 0 : presenceContext.initial, false);
  const motionValues = scrapeMotionValues(props);
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate: animate4 } = props;
  const isControllingVariants = checkIfControllingVariants(props);
  const isVariantNode = checkIfVariantNode(props);
  if (context && isVariantNode && !isControllingVariants && strict_equals(props.inherit, false, false)) {
    strict_equals(initial, null, false) && strict_equals(initial, void 0, false) ? initial : initial = context.initial;
    strict_equals(animate4, null, false) && strict_equals(animate4, void 0, false) ? animate4 : animate4 = context.animate;
  }
  const variantToSet = blockInitialAnimation || strict_equals(initial, false) ? animate4 : initial;
  if (variantToSet && strict_equals(typeof variantToSet, "boolean", false) && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved) return;
      const { transitionEnd, transition, ...target } = resolved;
      for (const key in target) values[key] = target[key];
      for (const key in transitionEnd) values[key] = transitionEnd[key];
    });
  }
  return values;
}
function UseVisualState($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseVisualState);
  const [$$stores, $$cleanup] = setup_stores();
  const $context = () => (validate_store(context, "context"), store_get(context, "$context", $$stores));
  const $presenceContext = () => (validate_store(presenceContext, "presenceContext"), store_get(presenceContext, "$presenceContext", $$stores));
  let config = prop($$props, "config", 8), props = prop($$props, "props", 8), isStatic = prop($$props, "isStatic", 8), isCustom = prop($$props, "isCustom", 8);
  const context = getContext(MotionContext) || MotionContext(isCustom());
  const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom());
  let state = mutable_source(makeState(config(), props(), get2(context), get2(presenceContext)));
  const ms = makeState;
  legacy_pre_effect(
    () => (deep_read_state(isStatic()), deep_read_state(config()), deep_read_state(props()), $context(), $presenceContext()),
    () => {
      if (isStatic()) {
        set(state, ms(config(), props(), $context(), $presenceContext()));
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(
    node,
    $$props,
    "default",
    {
      get state() {
        return get(state);
      }
    },
    null
  );
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  UseVisualState = hmr(UseVisualState, () => UseVisualState[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseVisualState[HMR].source;
    set(UseVisualState[HMR].source, module.default[HMR].original);
  });
}
var UseVisualState_default = UseVisualState;
mark_module_end(UseVisualState);

// node_modules/svelte-motion/src/utils/is-ref-object.js
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

// node_modules/svelte-motion/src/motion/utils/use-motion-ref.js
function useMotionRef(visualState, visualElement2, externalRef) {
  return function(instance) {
    var _a;
    instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));
    if (visualElement2) {
      instance ? visualElement2.mount(instance) : visualElement2.unmount();
    }
    if (externalRef) {
      if (typeof externalRef === "function") {
        externalRef(instance);
      } else if (isRefObject(externalRef)) {
        externalRef.current = instance;
      }
    }
  };
}

// node_modules/svelte-motion/src/motion/Motion.svelte
mark_module_start();
Motion[FILENAME] = "node_modules/svelte-motion/src/motion/Motion.svelte";
var root_5 = add_locations(template(`<!> <!>`, 1), Motion[FILENAME], []);
function Motion($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "isSVG",
    "forwardMotionProps",
    "externalRef",
    "targetEl"
  ]);
  push($$props, false, Motion);
  const [$$stores, $$cleanup] = setup_stores();
  const $a = () => (validate_store(a, "a"), store_get(a, "$a", $$stores));
  const motionProps = mutable_source();
  const isStatic = mutable_source();
  let isSVG = prop($$props, "isSVG", 8, false), forwardMotionProps = prop($$props, "forwardMotionProps", 8, false), externalRef = prop($$props, "externalRef", 8, void 0), targetEl = prop($$props, "targetEl", 8, void 0);
  const isCustom = targetEl();
  let Component = isSVG() ? "SVG" : "DOM";
  let createVisualElement = createDomVisualElement;
  let visualStateConfig = isSVG() ? svgMotionConfig : htmlMotionConfig;
  const a = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  let mounted = mutable_source(false);
  const setContext2 = (c, v) => {
    c.visualElement = v;
    return v;
  };
  onMount(() => set(mounted, true));
  legacy_pre_effect(() => deep_read_state($$restProps), () => {
    set(motionProps, $$restProps);
  });
  legacy_pre_effect(() => (get(isStatic), $a()), () => {
    (($$value) => set(isStatic, $$value.isStatic))($a() || {});
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  ScaleCorrectionProvider_default(node, {
    isCustom,
    children: wrap_snippet(Motion, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      UseCreateMotionContext_default(node_1, {
        get props() {
          return get(motionProps);
        },
        get isStatic() {
          return get(isStatic);
        },
        isCustom,
        children: invalid_default_snippet,
        $$slots: {
          default: ($$anchor3, $$slotProps2) => {
            const context = derived_safe_equal(() => $$slotProps2.value);
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            UseVisualState_default(node_2, {
              config: visualStateConfig,
              get props() {
                return get(motionProps);
              },
              get isStatic() {
                return get(isStatic);
              },
              isCustom,
              children: invalid_default_snippet,
              $$slots: {
                default: ($$anchor4, $$slotProps3) => {
                  const visualState = derived_safe_equal(() => $$slotProps3.state);
                  var fragment_3 = comment();
                  var node_3 = first_child(fragment_3);
                  UseVisualElement_default(node_3, {
                    Component,
                    get visualState() {
                      return get(visualState);
                    },
                    createVisualElement,
                    get props() {
                      return get(motionProps);
                    },
                    isCustom,
                    children: invalid_default_snippet,
                    $$slots: {
                      default: ($$anchor5, $$slotProps4) => {
                        const visualElement2 = derived_safe_equal(() => $$slotProps4.visualElement);
                        var fragment_4 = comment();
                        var node_4 = first_child(fragment_4);
                        const expression = derived_safe_equal(() => setContext2(get(context), get(visualElement2)));
                        UseFeatures_default(node_4, {
                          get visualElement() {
                            return get(expression);
                          },
                          get props() {
                            return get(motionProps);
                          },
                          children: invalid_default_snippet,
                          $$slots: {
                            default: ($$anchor6, $$slotProps5) => {
                              const _features = derived_safe_equal(() => $$slotProps5.features);
                              var fragment_5 = root_5();
                              var node_5 = first_child(fragment_5);
                              MotionContextProvider_default(node_5, {
                                get value() {
                                  return get(context);
                                },
                                isCustom,
                                children: wrap_snippet(Motion, ($$anchor7, $$slotProps6) => {
                                  var fragment_6 = comment();
                                  var node_6 = first_child(fragment_6);
                                  const expression_1 = derived_safe_equal(() => useMotionRef(get(visualState), get(context).visualElement, externalRef()));
                                  UseRender_default(node_6, {
                                    Component,
                                    get props() {
                                      return get(motionProps);
                                    },
                                    get ref() {
                                      return get(expression_1);
                                    },
                                    get visualState() {
                                      return get(visualState);
                                    },
                                    get isStatic() {
                                      return get(isStatic);
                                    },
                                    get forwardMotionProps() {
                                      return forwardMotionProps();
                                    },
                                    children: invalid_default_snippet,
                                    $$slots: {
                                      default: ($$anchor8, $$slotProps7) => {
                                        const motion2 = derived_safe_equal(() => $$slotProps7.motion);
                                        const renderProps = derived_safe_equal(() => $$slotProps7.props);
                                        var fragment_7 = comment();
                                        var node_7 = first_child(fragment_7);
                                        slot(
                                          node_7,
                                          $$props,
                                          "default",
                                          {
                                            get motion() {
                                              return get(motion2);
                                            },
                                            get props() {
                                              return get(renderProps);
                                            }
                                          },
                                          null
                                        );
                                        append($$anchor8, fragment_7);
                                      }
                                    }
                                  });
                                  append($$anchor7, fragment_6);
                                }),
                                $$slots: { default: true }
                              });
                              var node_8 = sibling(node_5, 2);
                              {
                                var consequent = ($$anchor7) => {
                                  var fragment_8 = comment();
                                  var node_9 = first_child(fragment_8);
                                  validate_each_keys(() => get(_features), (feat) => feat.key);
                                  each(node_9, 1, () => get(_features), (feat) => feat.key, ($$anchor8, feat) => {
                                    var fragment_9 = comment();
                                    var node_10 = first_child(fragment_9);
                                    component(node_10, () => get(feat).Component, ($$anchor9, $$component) => {
                                      $$component($$anchor9, {
                                        get props() {
                                          return get(feat).props;
                                        },
                                        get visualElement() {
                                          return get(feat).visualElement;
                                        },
                                        isCustom
                                      });
                                    });
                                    append($$anchor8, fragment_9);
                                  });
                                  append($$anchor7, fragment_8);
                                };
                                if_block(node_8, ($$render) => {
                                  if (get(mounted)) $$render(consequent);
                                });
                              }
                              append($$anchor6, fragment_5);
                            }
                          }
                        });
                        append($$anchor5, fragment_4);
                      }
                    }
                  });
                  append($$anchor4, fragment_3);
                }
              }
            });
            append($$anchor3, fragment_2);
          }
        }
      });
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Motion = hmr(Motion, () => Motion[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Motion[HMR].source;
    set(Motion[HMR].source, module.default[HMR].original);
  });
}
var Motion_default = Motion;
mark_module_end(Motion);

// node_modules/svelte-motion/src/motion/index.js
var createMotionComponent = ({
  preloadedFeatures,
  createVisualElement,
  forwardMotionProps,
  visualStateConfig,
  Component
}) => {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  return class MotionComponent extends Motion_default {
    constructor(options) {
      const props = options.props;
      options.props = {
        props,
        defaultFeatures: preloadedFeatures,
        createVisualElement,
        forwardMotionProps,
        Component,
        visualStateConfig
      };
      super(options);
    }
  };
};

// node_modules/svelte-motion/src/events/UseDomEvent.svelte
mark_module_start();
UseDomEvent[FILENAME] = "node_modules/svelte-motion/src/events/UseDomEvent.svelte";
function addDomEvent(target, eventName, handler, options) {
  target.addEventListener(eventName, handler, options);
  return function() {
    return target.removeEventListener(eventName, handler, options);
  };
}
function UseDomEvent($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseDomEvent);
  let ref = prop($$props, "ref", 8), eventName = prop($$props, "eventName", 8), handler = prop($$props, "handler", 8, void 0), options = prop($$props, "options", 8, void 0);
  let cleanup = mutable_source(() => {
  });
  const effect = () => {
    get(cleanup)();
    if (!ref()) {
      return () => {
      };
    }
    const element2 = ref().current;
    if (handler() && element2) {
      return addDomEvent(element2, eventName(), handler(), options());
    }
    return () => {
    };
  };
  onDestroy(get(cleanup));
  legacy_pre_effect(
    () => (deep_read_state(ref()), deep_read_state(eventName()), deep_read_state(handler()), deep_read_state(options())),
    () => {
      set(cleanup, effect(ref(), eventName(), handler(), options()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseDomEvent = hmr(UseDomEvent, () => UseDomEvent[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseDomEvent[HMR].source;
    set(UseDomEvent[HMR].source, module.default[HMR].original);
  });
}
var UseDomEvent_default = UseDomEvent;
mark_module_end(UseDomEvent);

// node_modules/svelte-motion/src/gestures/utils/event-type.js
function isMouseEvent(event) {
  if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof MouseEvent;
}
function isTouchEvent(event) {
  var hasTouches = !!event.touches;
  return hasTouches;
}

// node_modules/svelte-motion/src/events/event-info.js
function filterPrimaryPointer(eventHandler) {
  return function(event) {
    var isMouseEvent2 = event instanceof MouseEvent;
    var isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
var defaultPagePoint = { pageX: 0, pageY: 0 };
function pointFromTouch(e, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  var primaryTouch = e.touches[0] || e.changedTouches[0];
  var point = primaryTouch || defaultPagePoint;
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function pointFromMouse(point, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function extractEventInfo(event, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
function getViewportPointFromEvent(event) {
  return extractEventInfo(event, "client");
}
var wrapHandler = function(handler, shouldFilterPrimaryPointer) {
  if (shouldFilterPrimaryPointer === void 0) {
    shouldFilterPrimaryPointer = false;
  }
  var listener = function(event) {
    return handler(event, extractEventInfo(event));
  };
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
};

// node_modules/svelte-motion/src/gestures/PanSession.js
import sync6, { getFrameData as getFrameData2, cancelSync as cancelSync2 } from "framesync";

// node_modules/svelte-motion/src/utils/is-browser.js
var isBrowser = typeof window !== "undefined";

// node_modules/svelte-motion/src/events/utils.js
var supportsPointerEvents = function() {
  return isBrowser && window.onpointerdown === null;
};
var supportsTouchEvents = function() {
  return isBrowser && window.ontouchstart === null;
};
var supportsMouseEvents = function() {
  return isBrowser && window.onmousedown === null;
};

// node_modules/svelte-motion/src/events/UsePointerEvent.svelte
mark_module_start();
UsePointerEvent[FILENAME] = "node_modules/svelte-motion/src/events/UsePointerEvent.svelte";
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name) {
  if (supportsPointerEvents()) {
    return name;
  } else if (supportsTouchEvents()) {
    return touchEventNames[name];
  } else if (supportsMouseEvents()) {
    return mouseEventNames[name];
  }
  return name;
}
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, strict_equals(eventName, "pointerdown")), options);
}
function UsePointerEvent($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UsePointerEvent);
  let ref = prop($$props, "ref", 8), eventName = prop($$props, "eventName", 8), handler = prop($$props, "handler", 8, void 0), options = prop($$props, "options", 8, void 0);
  init();
  var fragment = comment();
  var node = first_child(fragment);
  const expression = derived_safe_equal(() => getPointerEventName(eventName()));
  const expression_1 = derived_safe_equal(() => handler() && wrapHandler(handler(), strict_equals(eventName(), "pointerdown")));
  UseDomEvent_default(node, {
    get ref() {
      return ref();
    },
    get eventName() {
      return get(expression);
    },
    get handler() {
      return get(expression_1);
    },
    get options() {
      return options();
    },
    children: wrap_snippet(UsePointerEvent, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UsePointerEvent = hmr(UsePointerEvent, () => UsePointerEvent[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UsePointerEvent[HMR].source;
    set(UsePointerEvent[HMR].source, module.default[HMR].original);
  });
}
var UsePointerEvent_default = UsePointerEvent;
mark_module_end(UsePointerEvent);

// node_modules/svelte-motion/src/gestures/PanSession.js
import { distance as distance2, pipe as pipe2 } from "popmotion";
var PanSession = (
  /** @class */
  function() {
    function PanSession2(event, handlers, _a) {
      var _this = this;
      var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.updatePoint = function() {
        if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))
          return;
        var info2 = getPanInfo(_this.lastMoveEventInfo, _this.history);
        var isPanStarted = _this.startEvent !== null;
        var isDistancePastThreshold = distance2(info2.offset, { x: 0, y: 0 }) >= 3;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        var point2 = info2.point;
        var timestamp2 = getFrameData2().timestamp;
        _this.history.push(Object.assign(Object.assign({}, point2), { timestamp: timestamp2 }));
        var _a2 = _this.handlers, onStart = _a2.onStart, onMove = _a2.onMove;
        if (!isPanStarted) {
          onStart && onStart(_this.lastMoveEvent, info2);
          _this.startEvent = _this.lastMoveEvent;
        }
        onMove && onMove(_this.lastMoveEvent, info2);
      };
      this.handlePointerMove = function(event2, info2) {
        _this.lastMoveEvent = event2;
        _this.lastMoveEventInfo = transformPoint(info2, _this.transformPagePoint);
        if (isMouseEvent(event2) && event2.buttons === 0) {
          _this.handlePointerUp(event2, info2);
          return;
        }
        sync6.update(_this.updatePoint, true);
      };
      this.handlePointerUp = function(event2, info2) {
        _this.end();
        var _a2 = _this.handlers, onEnd = _a2.onEnd, onSessionEnd = _a2.onSessionEnd;
        var panInfo = getPanInfo(transformPoint(info2, _this.transformPagePoint), _this.history);
        if (_this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (isTouchEvent(event) && event.touches.length > 1)
        return;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      var info = extractEventInfo(event);
      var initialInfo = transformPoint(info, this.transformPagePoint);
      var point = initialInfo.point;
      var timestamp = getFrameData2().timestamp;
      this.history = [Object.assign(Object.assign({}, point), { timestamp })];
      var onSessionStart = handlers.onSessionStart;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe2(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
    }
    PanSession2.prototype.updateHandlers = function(handlers) {
      this.handlers = handlers;
    };
    PanSession2.prototype.end = function() {
      this.removeListeners && this.removeListeners();
      cancelSync2.update(this.updatePoint);
    };
    return PanSession2;
  }()
);
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function getPanInfo(_a, history) {
  var point = _a.point;
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity2(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity2(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  var i = history.length - 1;
  var timestampedPoint = null;
  var lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time === 0) {
    return { x: 0, y: 0 };
  }
  var currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}

// node_modules/svelte-motion/src/gestures/UsePanGesture.svelte
mark_module_start();
UsePanGesture[FILENAME] = "node_modules/svelte-motion/src/gestures/UsePanGesture.svelte";
function UsePanGesture($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UsePanGesture);
  const [$$stores, $$cleanup] = setup_stores();
  const $mcc = () => (validate_store(mcc, "mcc"), store_get(mcc, "$mcc", $$stores));
  const hasPanEvents = mutable_source();
  let props = prop($$props, "props", 8), visualElement2 = prop($$props, "visualElement", 8), isCustom = prop($$props, "isCustom", 8);
  let tmp = props(), onPan = mutable_source(tmp.onPan), onPanStart = mutable_source(tmp.onPanStart), onPanEnd = mutable_source(tmp.onPanEnd), onPanSessionStart = mutable_source(tmp.onPanSessionStart);
  let panSession = mutable_source(null);
  const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom());
  let tmp_1 = get2(mcc), transformPagePoint = mutable_source(tmp_1.transformPagePoint);
  let handlers = mutable_source({
    onSessionStart: get(onPanSessionStart),
    onStart: get(onPanStart),
    onMove: get(onPan),
    onEnd: (event, info) => {
      set(panSession, null);
      get(onPanEnd) && get(onPanEnd)(event, info);
    }
  });
  function onPointerDown(event) {
    set(panSession, new PanSession(event, get(handlers), {
      transformPagePoint: get(transformPagePoint)
    }));
  }
  afterUpdate(() => {
    if (strict_equals(get(panSession), null, false)) {
      get(panSession).updateHandlers(get(handlers));
    }
  });
  onDestroy(() => get(panSession) && get(panSession).end());
  legacy_pre_effect(
    () => (get(onPan), get(onPanStart), get(onPanEnd), get(onPanSessionStart), deep_read_state(props())),
    () => {
      (($$value) => (set(onPan, $$value.onPan), set(onPanStart, $$value.onPanStart), set(onPanEnd, $$value.onPanEnd), set(onPanSessionStart, $$value.onPanSessionStart)))(props());
    }
  );
  legacy_pre_effect(
    () => (get(onPan), get(onPanStart), get(onPanEnd), get(onPanSessionStart)),
    () => {
      set(hasPanEvents, get(onPan) || get(onPanStart) || get(onPanEnd) || get(onPanSessionStart));
    }
  );
  legacy_pre_effect(() => (get(transformPagePoint), $mcc()), () => {
    (($$value) => set(transformPagePoint, $$value.transformPagePoint))($mcc());
  });
  legacy_pre_effect(
    () => (get(onPanSessionStart), get(onPanStart), get(onPan), get(onPanEnd)),
    () => {
      set(handlers, {
        onSessionStart: get(onPanSessionStart),
        onStart: get(onPanStart),
        onMove: get(onPan),
        onEnd: (event, info) => {
          set(panSession, null);
          get(onPanEnd) && get(onPanEnd)(event, info);
        }
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  const expression = derived_safe_equal(() => get(hasPanEvents) && onPointerDown);
  UsePointerEvent_default(node, {
    get ref() {
      return visualElement2();
    },
    eventName: "pointerdown",
    get handler() {
      return get(expression);
    },
    children: wrap_snippet(UsePanGesture, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  UsePanGesture = hmr(UsePanGesture, () => UsePanGesture[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UsePanGesture[HMR].source;
    set(UsePanGesture[HMR].source, module.default[HMR].original);
  });
}
var UsePanGesture_default = UsePanGesture;
mark_module_end(UsePanGesture);

// node_modules/svelte-motion/src/gestures/utils/is-node-or-child.js
var isNodeOrChild = function(parent, child2) {
  if (!child2) {
    return false;
  } else if (parent === child2) {
    return true;
  } else {
    return isNodeOrChild(parent, child2.parentElement);
  }
};

// node_modules/svelte-motion/src/gestures/UseTapGesture.svelte
import { pipe as pipe3 } from "popmotion";

// node_modules/svelte-motion/src/gestures/drag/utils/lock.js
function createLock(name) {
  var lock = null;
  return function() {
    var openLock = function() {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  var lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    var openHorizontal_1 = globalHorizontalLock();
    var openVertical_1 = globalVerticalLock();
    if (openHorizontal_1 && openVertical_1) {
      lock = function() {
        openHorizontal_1();
        openVertical_1();
      };
    } else {
      if (openHorizontal_1)
        openHorizontal_1();
      if (openVertical_1)
        openVertical_1();
    }
  }
  return lock;
}
function isDragActive() {
  var openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}

// node_modules/svelte-motion/src/gestures/UseTapGesture.svelte
mark_module_start();
UseTapGesture[FILENAME] = "node_modules/svelte-motion/src/gestures/UseTapGesture.svelte";
function UseTapGesture($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseTapGesture);
  const onTap = mutable_source();
  const onTapStart = mutable_source();
  const onTapCancel = mutable_source();
  const whileTap = mutable_source();
  const hasPressListeners = mutable_source();
  let props = prop($$props, "props", 8), visualElement2 = prop($$props, "visualElement", 8);
  let isPressing = false;
  let cancelPointerEndListeners = null;
  function removePointerEndListener() {
    cancelPointerEndListeners == null ? void 0 : cancelPointerEndListeners();
    cancelPointerEndListeners = null;
  }
  function checkPointerEnd() {
    var _a;
    removePointerEndListener();
    isPressing = false;
    (_a = visualElement2().animationState) == null ? void 0 : _a.setActive(AnimationType.Tap, false);
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    var _a, _b;
    if (!checkPointerEnd()) return;
    !isNodeOrChild(visualElement2().getInstance(), event.target) ? (_a = get(onTapCancel)) == null ? void 0 : _a(event, info) : (_b = get(onTap)) == null ? void 0 : _b(event, info);
  }
  function onPointerCancel(event, info) {
    var _a;
    if (!checkPointerEnd()) return;
    (_a = get(onTapCancel)) == null ? void 0 : _a(event, info);
  }
  function onPointerDown(event, info) {
    var _a, _b;
    if (isPressing) return;
    removePointerEndListener();
    isPressing = true;
    cancelPointerEndListeners = pipe3(addPointerEvent(window, "pointerup", onPointerUp), addPointerEvent(window, "pointercancel", onPointerCancel));
    (_a = get(onTapStart)) == null ? void 0 : _a(event, info);
    (_b = visualElement2().animationState) == null ? void 0 : _b.setActive(AnimationType.Tap, true);
  }
  onDestroy(removePointerEndListener);
  legacy_pre_effect(
    () => (get(onTap), get(onTapStart), get(onTapCancel), get(whileTap), deep_read_state(props())),
    () => {
      (($$value) => (set(onTap, $$value.onTap), set(onTapStart, $$value.onTapStart), set(onTapCancel, $$value.onTapCancel), set(whileTap, $$value.whileTap)))(props());
    }
  );
  legacy_pre_effect(
    () => (get(onTap), get(onTapStart), get(onTapCancel), get(whileTap)),
    () => {
      set(hasPressListeners, get(onTap) || get(onTapStart) || get(onTapCancel) || get(whileTap));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  const expression = derived_safe_equal(() => get(hasPressListeners) ? onPointerDown : void 0);
  UsePointerEvent_default(node, {
    get ref() {
      return visualElement2();
    },
    eventName: "pointerdown",
    get handler() {
      return get(expression);
    },
    children: wrap_snippet(UseTapGesture, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseTapGesture = hmr(UseTapGesture, () => UseTapGesture[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseTapGesture[HMR].source;
    set(UseTapGesture[HMR].source, module.default[HMR].original);
  });
}
var UseTapGesture_default = UseTapGesture;
mark_module_end(UseTapGesture);

// node_modules/svelte-motion/src/gestures/UseHoverGesture.svelte
mark_module_start();
UseHoverGesture[FILENAME] = "node_modules/svelte-motion/src/gestures/UseHoverGesture.svelte";
function createHoverEvent(visualElement2, isActive, callback) {
  return (event, info) => {
    var _a;
    if (!isMouseEvent(event) || isDragActive()) return;
    callback == null ? void 0 : callback(event, info);
    (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Hover, isActive);
  };
}
var root = add_locations(template(`<!> <!> <!>`, 1), UseHoverGesture[FILENAME], []);
function UseHoverGesture($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseHoverGesture);
  let props = prop($$props, "props", 8), visualElement2 = prop($$props, "visualElement", 8);
  let tmp = props(), onHoverStart = mutable_source(tmp.onHoverStart), onHoverEnd = mutable_source(tmp.onHoverEnd), whileHover = mutable_source(tmp.whileHover);
  legacy_pre_effect(
    () => (get(onHoverStart), get(onHoverEnd), get(whileHover), deep_read_state(props())),
    () => {
      (($$value) => (set(onHoverStart, $$value.onHoverStart), set(onHoverEnd, $$value.onHoverEnd), set(whileHover, $$value.whileHover)))(props());
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = root();
  var node = first_child(fragment);
  const expression = derived_safe_equal(() => get(onHoverStart) || get(whileHover) ? createHoverEvent(visualElement2(), true, get(onHoverStart)) : void 0);
  UsePointerEvent_default(node, {
    get ref() {
      return visualElement2();
    },
    eventName: "pointerenter",
    get handler() {
      return get(expression);
    }
  });
  var node_1 = sibling(node, 2);
  const expression_1 = derived_safe_equal(() => get(onHoverEnd) || get(whileHover) ? createHoverEvent(visualElement2(), false, get(onHoverEnd)) : void 0);
  UsePointerEvent_default(node_1, {
    get ref() {
      return visualElement2();
    },
    eventName: "pointerleave",
    get handler() {
      return get(expression_1);
    }
  });
  var node_2 = sibling(node_1, 2);
  slot(node_2, $$props, "default", {}, null);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseHoverGesture = hmr(UseHoverGesture, () => UseHoverGesture[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseHoverGesture[HMR].source;
    set(UseHoverGesture[HMR].source, module.default[HMR].original);
  });
}
var UseHoverGesture_default = UseHoverGesture;
mark_module_end(UseHoverGesture);

// node_modules/svelte-motion/src/gestures/UseFocusGesture.svelte
mark_module_start();
UseFocusGesture[FILENAME] = "node_modules/svelte-motion/src/gestures/UseFocusGesture.svelte";
function UseFocusGesture($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseFocusGesture);
  const whileFocus = mutable_source();
  let props = prop($$props, "props", 8), visualElement2 = prop($$props, "visualElement", 8);
  const onFocus = () => {
    var _a;
    (_a = visualElement2().animationState) == null ? void 0 : _a.setActive(AnimationType.Focus, true);
  };
  const onBlur = () => {
    var _a;
    (_a = visualElement2().animationState) == null ? void 0 : _a.setActive(AnimationType.Focus, false);
  };
  legacy_pre_effect(
    () => (get(whileFocus), deep_read_state(props())),
    () => {
      (($$value) => set(whileFocus, $$value.whileFocus))(props());
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  const expression = derived_safe_equal(() => get(whileFocus) ? onFocus : void 0);
  UseDomEvent_default(node, {
    get ref() {
      return visualElement2();
    },
    eventName: "focus",
    get handler() {
      return get(expression);
    },
    children: wrap_snippet(UseFocusGesture, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      const expression_1 = derived_safe_equal(() => get(whileFocus) ? onBlur : void 0);
      UseDomEvent_default(node_1, {
        get ref() {
          return visualElement2();
        },
        eventName: "blur",
        get handler() {
          return get(expression_1);
        },
        children: wrap_snippet(UseFocusGesture, ($$anchor3, $$slotProps2) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          slot(node_2, $$props, "default", {}, null);
          append($$anchor3, fragment_2);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseFocusGesture = hmr(UseFocusGesture, () => UseFocusGesture[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseFocusGesture[HMR].source;
    set(UseFocusGesture[HMR].source, module.default[HMR].original);
  });
}
var UseFocusGesture_default = UseFocusGesture;
mark_module_end(UseFocusGesture);

// node_modules/svelte-motion/src/gestures/UseGestures.svelte
mark_module_start();
UseGestures[FILENAME] = "node_modules/svelte-motion/src/gestures/UseGestures.svelte";
var root2 = add_locations(template(`<!> <!> <!> <!> <!>`, 1), UseGestures[FILENAME], []);
function UseGestures($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseGestures);
  let props = prop($$props, "props", 8), visualElement2 = prop($$props, "visualElement", 8);
  var fragment = root2();
  var node = first_child(fragment);
  UsePanGesture_default(node, {
    get props() {
      return props();
    },
    get visualElement() {
      return visualElement2();
    }
  });
  var node_1 = sibling(node, 2);
  UseTapGesture_default(node_1, {
    get props() {
      return props();
    },
    get visualElement() {
      return visualElement2();
    }
  });
  var node_2 = sibling(node_1, 2);
  UseHoverGesture_default(node_2, {
    get props() {
      return props();
    },
    get visualElement() {
      return visualElement2();
    }
  });
  var node_3 = sibling(node_2, 2);
  UseFocusGesture_default(node_3, {
    get props() {
      return props();
    },
    get visualElement() {
      return visualElement2();
    }
  });
  var node_4 = sibling(node_3, 2);
  slot(node_4, $$props, "default", {}, null);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseGestures = hmr(UseGestures, () => UseGestures[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseGestures[HMR].source;
    set(UseGestures[HMR].source, module.default[HMR].original);
  });
}
var UseGestures_default = UseGestures;
mark_module_end(UseGestures);

// node_modules/svelte-motion/src/render/dom/create-motion-class.js
var createMotionClass = (features) => {
  features && loadFeatures(features);
  return Motion_default;
};

// node_modules/svelte-motion/src/motion/features/gestures.js
var gestureAnimations = {
  tap: UseTapGesture_default,
  focus: UseFocusGesture_default,
  hover: UseHoverGesture_default
};

// node_modules/svelte-motion/src/gestures/drag/VisualElementDragControls.js
import { __rest as __rest8, __spreadArray as __spreadArray9, __read as __read15 } from "tslib";
import { invariant } from "hey-listen";

// node_modules/svelte-motion/src/gestures/drag/utils/constraints.js
import { __read as __read14 } from "tslib";
import { mix as mix4 } from "popmotion";
function applyConstraints(point, _a, elastic) {
  var min = _a.min, max = _a.max;
  if (min !== void 0 && point < min) {
    point = elastic ? mix4(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mix4(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
function calcConstrainedMinPoint(point, length, progress4, constraints, elastic) {
  var min = point - length * progress4;
  return constraints ? applyConstraints(min, constraints, elastic) : min;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, _a) {
  var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  var _a;
  var min = constraintsAxis.min - layoutAxis.min;
  var max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    _a = __read14([max, min], 2), min = _a[0], max = _a[1];
  }
  return {
    min: layoutAxis.min + min,
    max: layoutAxis.min + max
  };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcPositionFromProgress(axis, constraints, progress4) {
  var axisLength = axis.max - axis.min;
  var min = mix4(constraints.min, constraints.max - axisLength, progress4);
  return { min, max: min + axisLength };
}
function rebaseAxisConstraints(layout, constraints) {
  var relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  var _a;
  return typeof dragElastic === "number" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;
}

// node_modules/svelte-motion/src/gestures/drag/VisualElementDragControls.js
import { progress as progress2 } from "popmotion";

// node_modules/svelte-motion/src/render/dom/projection/convert-to-relative.js
function convertToRelativeProjection(visualElement2, isLayoutDrag) {
  if (isLayoutDrag === void 0) {
    isLayoutDrag = true;
  }
  var projectionParent = visualElement2.getProjectionParent();
  if (!projectionParent)
    return false;
  var offset;
  if (isLayoutDrag) {
    offset = calcRelativeOffset(projectionParent.projection.target, visualElement2.projection.target);
    removeBoxTransforms(offset, projectionParent.getLatestValues());
  } else {
    offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement2.getLayoutState().layout);
  }
  eachAxis(function(axis) {
    return visualElement2.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);
  });
  return true;
}

// node_modules/svelte-motion/src/gestures/drag/VisualElementDragControls.js
import { flushSync as flushSync2 } from "framesync";
var elementDragControls = /* @__PURE__ */ new WeakMap();
var lastPointerEvent;
var VisualElementDragControls = (
  /** @class */
  function() {
    function VisualElementDragControls2(_a) {
      var visualElement2 = _a.visualElement;
      this.isDragging = false;
      this.currentDirection = null;
      this.constraints = false;
      this.elastic = axisBox();
      this.props = {};
      this.hasMutatedConstraints = false;
      this.cursorProgress = {
        x: 0.5,
        y: 0.5
      };
      this.originPoint = {};
      this.openGlobalLock = null;
      this.panSession = null;
      this.visualElement = visualElement2;
      this.visualElement.enableLayoutProjection();
      elementDragControls.set(visualElement2, this);
    }
    VisualElementDragControls2.prototype.start = function(originEvent, _a) {
      var _this = this;
      var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;
      var onSessionStart = function(event) {
        var _a2;
        _this.stopMotion();
        var initialPoint = getViewportPointFromEvent(event).point;
        (_a2 = _this.cancelLayout) === null || _a2 === void 0 ? void 0 : _a2.call(_this);
        _this.cancelLayout = batchLayout(function(read, write) {
          var ancestors = collectProjectingAncestors(_this.visualElement);
          var children = collectProjectingChildren(_this.visualElement);
          var tree = __spreadArray9(__spreadArray9([], __read15(ancestors)), __read15(children));
          var hasManuallySetCursorOrigin = false;
          _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();
          write(function() {
            tree.forEach(function(element2) {
              return element2.resetTransform();
            });
          });
          read(function() {
            updateLayoutMeasurement(_this.visualElement);
            children.forEach(updateLayoutMeasurement);
          });
          write(function() {
            tree.forEach(function(element2) {
              return element2.restoreTransform();
            });
            if (snapToCursor) {
              hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);
            }
          });
          read(function() {
            var isRelativeDrag = Boolean(_this.getAxisMotionValue("x") && !_this.isExternalDrag());
            if (!isRelativeDrag) {
              _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));
            }
            _this.visualElement.scheduleUpdateLayoutProjection();
            var projection = _this.visualElement.projection;
            eachAxis(function(axis) {
              if (!hasManuallySetCursorOrigin) {
                var _a3 = projection.target[axis], min = _a3.min, max = _a3.max;
                _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : progress2(min, max, initialPoint[axis]);
              }
              var axisValue = _this.getAxisMotionValue(axis);
              if (axisValue) {
                _this.originPoint[axis] = axisValue.get();
              }
            });
          });
          write(function() {
            flushSync2.update();
            flushSync2.preRender();
            flushSync2.render();
            flushSync2.postRender();
          });
          read(function() {
            return _this.resolveDragConstraints();
          });
        });
      };
      var onStart = function(event, info) {
        var _a2, _b2, _c2;
        var _d = _this.props, drag2 = _d.drag, dragPropagation = _d.dragPropagation;
        if (drag2 && !dragPropagation) {
          if (_this.openGlobalLock)
            _this.openGlobalLock();
          _this.openGlobalLock = getGlobalLock(drag2);
          if (!_this.openGlobalLock)
            return;
        }
        flushLayout();
        _this.isDragging = true;
        _this.currentDirection = null;
        (_b2 = (_a2 = _this.props).onDragStart) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event, info);
        (_c2 = _this.visualElement.animationState) === null || _c2 === void 0 ? void 0 : _c2.setActive(AnimationType.Drag, true);
      };
      var onMove = function(event, info) {
        var _a2, _b2, _c2, _d;
        var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;
        if (!dragPropagation && !_this.openGlobalLock)
          return;
        var offset = info.offset;
        if (dragDirectionLock && _this.currentDirection === null) {
          _this.currentDirection = getCurrentDirection(offset);
          if (_this.currentDirection !== null) {
            (_b2 = (_a2 = _this.props).onDirectionLock) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, _this.currentDirection);
          }
          return;
        }
        _this.updateAxis("x", info.point, offset);
        _this.updateAxis("y", info.point, offset);
        (_d = (_c2 = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c2, event, info);
        lastPointerEvent = event;
      };
      var onSessionEnd = function(event, info) {
        return _this.stop(event, info);
      };
      var transformPagePoint = this.props.transformPagePoint;
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd
      }, { transformPagePoint });
    };
    VisualElementDragControls2.prototype.resolveDragConstraints = function() {
      var _this = this;
      var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;
      var layout = this.visualElement.getLayoutState().layoutCorrected;
      if (dragConstraints) {
        this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(layout, dragConstraints) : calcRelativeConstraints(layout, dragConstraints);
      } else {
        this.constraints = false;
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (this.constraints && !this.hasMutatedConstraints) {
        eachAxis(function(axis) {
          if (_this.getAxisMotionValue(axis)) {
            _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);
          }
        });
      }
    };
    VisualElementDragControls2.prototype.resolveRefConstraints = function(layoutBox, constraints) {
      var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;
      var constraintsElement = constraints.current;
      invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
      this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);
      var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);
      if (onMeasureDragConstraints) {
        var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);
        }
      }
      return measuredConstraints;
    };
    VisualElementDragControls2.prototype.cancelDrag = function() {
      var _a, _b;
      this.visualElement.unlockProjectionTarget();
      (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);
      this.isDragging = false;
      this.panSession && this.panSession.end();
      this.panSession = null;
      if (!this.props.dragPropagation && this.openGlobalLock) {
        this.openGlobalLock();
        this.openGlobalLock = null;
      }
      (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);
    };
    VisualElementDragControls2.prototype.stop = function(event, info) {
      var _a, _b, _c;
      (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();
      this.panSession = null;
      var isDragging = this.isDragging;
      this.cancelDrag();
      if (!isDragging)
        return;
      var velocity = info.velocity;
      this.animateDragEnd(velocity);
      (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);
    };
    VisualElementDragControls2.prototype.snapToCursor = function(point) {
      var _this = this;
      return eachAxis(function(axis) {
        var drag2 = _this.props.drag;
        if (!shouldDrag(axis, drag2, _this.currentDirection))
          return;
        var axisValue = _this.getAxisMotionValue(axis);
        if (axisValue) {
          var box = _this.visualElement.getLayoutState().layout;
          var length_1 = box[axis].max - box[axis].min;
          var center = box[axis].min + length_1 / 2;
          var offset = point[axis] - center;
          _this.originPoint[axis] = point[axis];
          axisValue.set(offset);
        } else {
          _this.cursorProgress[axis] = 0.5;
          return true;
        }
      }).includes(true);
    };
    VisualElementDragControls2.prototype.updateAxis = function(axis, point, offset) {
      var drag2 = this.props.drag;
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      return this.getAxisMotionValue(axis) ? this.updateAxisMotionValue(axis, offset) : this.updateVisualElementAxis(axis, point);
    };
    VisualElementDragControls2.prototype.updateAxisMotionValue = function(axis, offset) {
      var axisValue = this.getAxisMotionValue(axis);
      if (!offset || !axisValue)
        return;
      var nextValue = this.originPoint[axis] + offset[axis];
      var update = this.constraints ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis]) : nextValue;
      axisValue.set(update);
    };
    VisualElementDragControls2.prototype.updateVisualElementAxis = function(axis, point) {
      var _a;
      var axisLayout = this.visualElement.getLayoutState().layout[axis];
      var axisLength = axisLayout.max - axisLayout.min;
      var axisProgress = this.cursorProgress[axis];
      var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);
      this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);
    };
    VisualElementDragControls2.prototype.setProps = function(_a) {
      var _b = _a.drag, drag2 = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest8(_a, ["drag", "dragDirectionLock", "dragPropagation", "dragConstraints", "dragElastic", "dragMomentum"]);
      this.props = Object.assign({
        drag: drag2,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum
      }, remainingProps);
    };
    VisualElementDragControls2.prototype.getAxisMotionValue = function(axis) {
      var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;
      var dragKey = "_drag" + axis.toUpperCase();
      if (this.props[dragKey]) {
        return this.props[dragKey];
      } else if (!layout && layoutId === void 0) {
        return this.visualElement.getValue(axis, 0);
      }
    };
    VisualElementDragControls2.prototype.isLayoutDrag = function() {
      return !this.getAxisMotionValue("x");
    };
    VisualElementDragControls2.prototype.isExternalDrag = function() {
      var _a = this.props, _dragX = _a._dragX, _dragY = _a._dragY;
      return _dragX || _dragY;
    };
    VisualElementDragControls2.prototype.animateDragEnd = function(velocity) {
      var _this = this;
      var _a = this.props, drag2 = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;
      var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());
      var constraints = this.constraints || {};
      if (isRelative && Object.keys(constraints).length && this.isLayoutDrag()) {
        var projectionParent = this.visualElement.getProjectionParent();
        if (projectionParent) {
          var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);
          eachAxis(function(axis) {
            var _a2 = relativeConstraints_1[axis], min = _a2.min, max = _a2.max;
            constraints[axis] = {
              min: isNaN(min) ? void 0 : min,
              max: isNaN(max) ? void 0 : max
            };
          });
        }
      }
      var momentumAnimations = eachAxis(function(axis) {
        var _a2;
        if (!shouldDrag(axis, drag2, _this.currentDirection)) {
          return;
        }
        var transition = (_a2 = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a2 !== void 0 ? _a2 : {};
        var bounceStiffness = dragElastic ? 200 : 1e6;
        var bounceDamping = dragElastic ? 40 : 1e7;
        var inertia2 = Object.assign(Object.assign({
          type: "inertia",
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10
        }, dragTransition), transition);
        return _this.getAxisMotionValue(axis) ? _this.startAxisValueAnimation(axis, inertia2) : _this.visualElement.startLayoutAnimation(axis, inertia2, isRelative);
      });
      return Promise.all(momentumAnimations).then(function() {
        var _a2, _b;
        (_b = (_a2 = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a2);
      });
    };
    VisualElementDragControls2.prototype.stopMotion = function() {
      var _this = this;
      eachAxis(function(axis) {
        var axisValue = _this.getAxisMotionValue(axis);
        axisValue ? axisValue.stop() : _this.visualElement.stopLayoutAnimation();
      });
    };
    VisualElementDragControls2.prototype.startAxisValueAnimation = function(axis, transition) {
      var axisValue = this.getAxisMotionValue(axis);
      if (!axisValue)
        return;
      var currentValue = axisValue.get();
      axisValue.set(currentValue);
      axisValue.set(currentValue);
      return startAnimation(axis, axisValue, 0, transition);
    };
    VisualElementDragControls2.prototype.scalePoint = function() {
      var _this = this;
      var _a = this.props, drag2 = _a.drag, dragConstraints = _a.dragConstraints;
      if (!isRefObject(dragConstraints) || !this.constraintsBox)
        return;
      this.stopMotion();
      var boxProgress = { x: 0, y: 0 };
      eachAxis(function(axis) {
        boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);
      });
      this.updateConstraints(function() {
        eachAxis(function(axis) {
          if (!shouldDrag(axis, drag2, null))
            return;
          var _a2 = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a2.min, max = _a2.max;
          _this.visualElement.setProjectionTargetAxis(axis, min, max);
        });
      });
      setTimeout(flushLayout, 1);
    };
    VisualElementDragControls2.prototype.updateConstraints = function(onReady) {
      var _this = this;
      this.cancelLayout = batchLayout(function(read, write) {
        var ancestors = collectProjectingAncestors(_this.visualElement);
        write(function() {
          return ancestors.forEach(function(element2) {
            return element2.resetTransform();
          });
        });
        read(function() {
          return updateLayoutMeasurement(_this.visualElement);
        });
        write(function() {
          return ancestors.forEach(function(element2) {
            return element2.restoreTransform();
          });
        });
        read(function() {
          _this.resolveDragConstraints();
        });
        if (onReady)
          write(onReady);
      });
    };
    VisualElementDragControls2.prototype.mount = function(visualElement2) {
      var _this = this;
      var element2 = visualElement2.getInstance();
      var stopPointerListener = addPointerEvent(element2, "pointerdown", function(event) {
        var _a = _this.props, drag2 = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;
        drag2 && dragListener && _this.start(event);
      });
      var stopResizeListener = addDomEvent(window, "resize", function() {
        _this.scalePoint();
      });
      var stopLayoutUpdateListener = visualElement2.onLayoutUpdate(function() {
        if (_this.isDragging) {
          _this.resolveDragConstraints();
        }
      });
      var prevDragCursor = visualElement2.prevDragCursor;
      if (prevDragCursor) {
        this.start(lastPointerEvent, { cursorProgress: prevDragCursor });
      }
      return function() {
        stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();
        stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();
        stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();
        _this.cancelDrag();
      };
    };
    return VisualElementDragControls2;
  }()
);
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold) {
  if (lockThreshold === void 0) {
    lockThreshold = 10;
  }
  var direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}

// node_modules/svelte-motion/src/gestures/drag/UseDrag.svelte
mark_module_start();
UseDrag[FILENAME] = "node_modules/svelte-motion/src/gestures/drag/UseDrag.svelte";
function UseDrag($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseDrag);
  const [$$stores, $$cleanup] = setup_stores();
  const $mcc = () => (validate_store(mcc, "mcc"), store_get(mcc, "$mcc", $$stores));
  let visualElement2 = prop($$props, "visualElement", 8), props = prop($$props, "props", 8), isCustom = prop($$props, "isCustom", 8);
  const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom());
  let dragControls = new VisualElementDragControls({ visualElement: visualElement2() });
  let cleanup;
  const dragEffect = () => {
    if (cleanup) {
      cleanup();
    }
    if (get(groupDragControls)) {
      cleanup = get(groupDragControls).subscribe(dragControls);
    }
  };
  let tmp = props(), groupDragControls = mutable_source(tmp.dragControls);
  let tmp_1 = get2(mcc), transformPagePoint = mutable_source(tmp_1.transformPagePoint);
  dragControls.setProps({
    ...props(),
    transformPagePoint: get(transformPagePoint)
  });
  onDestroy(() => {
    if (cleanup) {
      cleanup();
    }
  });
  onMount(() => dragControls.mount(visualElement2()));
  legacy_pre_effect(
    () => (get(groupDragControls), deep_read_state(props())),
    () => {
      (($$value) => set(groupDragControls, $$value.dragControls))(props());
    }
  );
  legacy_pre_effect(() => (get(transformPagePoint), $mcc()), () => {
    (($$value) => set(transformPagePoint, $$value.transformPagePoint))($mcc());
  });
  legacy_pre_effect(
    () => (deep_read_state(props()), get(transformPagePoint)),
    () => {
      dragControls.setProps({
        ...props(),
        transformPagePoint: get(transformPagePoint)
      });
    }
  );
  legacy_pre_effect(() => {
  }, () => {
    dragEffect(dragControls);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  UseDrag = hmr(UseDrag, () => UseDrag[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseDrag[HMR].source;
    set(UseDrag[HMR].source, module.default[HMR].original);
  });
}
var UseDrag_default = UseDrag;
mark_module_end(UseDrag);

// node_modules/svelte-motion/src/motion/features/drag.js
var drag = {
  pan: UsePanGesture_default,
  drag: UseDrag_default
};

// node_modules/svelte-motion/src/render/dom/projection/default-scale-correctors.js
import { complex as complex5, px as px6 } from "style-value-types";
import { mix as mix5 } from "popmotion";
function pixelsToPercent(pixels, axis) {
  return pixels / (axis.max - axis.min) * 100;
}
function correctBorderRadius(latest, _layoutState, _a) {
  var target = _a.target;
  if (typeof latest === "string") {
    if (px6.test(latest)) {
      latest = parseFloat(latest);
    } else {
      return latest;
    }
  }
  var x = pixelsToPercent(latest, target.x);
  var y = pixelsToPercent(latest, target.y);
  return x + "% " + y + "%";
}
var varToken = "_$css";
function correctBoxShadow(latest, _a) {
  var delta2 = _a.delta, treeScale = _a.treeScale;
  var original = latest;
  var containsCSSVariables = latest.includes("var(");
  var cssVariables = [];
  if (containsCSSVariables) {
    latest = latest.replace(cssVariableRegex, function(match) {
      cssVariables.push(match);
      return varToken;
    });
  }
  var shadow = complex5.parse(latest);
  if (shadow.length > 5)
    return original;
  var template2 = complex5.createTransformer(latest);
  var offset = typeof shadow[0] !== "number" ? 1 : 0;
  var xScale = delta2.x.scale * treeScale.x;
  var yScale = delta2.y.scale * treeScale.y;
  shadow[0 + offset] /= xScale;
  shadow[1 + offset] /= yScale;
  var averageScale = mix5(xScale, yScale, 0.5);
  if (typeof shadow[2 + offset] === "number")
    shadow[2 + offset] /= averageScale;
  if (typeof shadow[3 + offset] === "number")
    shadow[3 + offset] /= averageScale;
  var output = template2(shadow);
  if (containsCSSVariables) {
    var i_1 = 0;
    output = output.replace(varToken, function() {
      var cssVariable = cssVariables[i_1];
      i_1++;
      return cssVariable;
    });
  }
  return output;
}
var borderCorrectionDefinition = {
  process: correctBorderRadius
};
var defaultScaleCorrectors = {
  borderRadius: Object.assign(Object.assign({}, borderCorrectionDefinition), { applyTo: [
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ] }),
  borderTopLeftRadius: borderCorrectionDefinition,
  borderTopRightRadius: borderCorrectionDefinition,
  borderBottomLeftRadius: borderCorrectionDefinition,
  borderBottomRightRadius: borderCorrectionDefinition,
  boxShadow: {
    process: correctBoxShadow
  }
};

// node_modules/svelte-motion/src/motion/features/layout/Animate.svelte
mark_module_start();
Animate[FILENAME] = "node_modules/svelte-motion/src/motion/features/layout/Animate.svelte";
var progressTarget = 1e3;
function hasMoved(a, b) {
  return !isZeroBox(a) && !isZeroBox(b) && (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y));
}
var zeroAxis = { min: 0, max: 0 };
function isZeroBox(a) {
  return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);
}
function axisIsEqual(a, b) {
  return strict_equals(a.min, b.min) && strict_equals(a.max, b.max);
}
var defaultLayoutTransition = { duration: 0.45, ease: [0.4, 0, 0.1, 1] };
function Animate($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Animate);
  let visualElement2 = prop($$props, "visualElement", 12), layout = prop($$props, "layout", 8, void 0), safeToRemove = prop($$props, "safeToRemove", 8);
  let frameTarget = axisBox();
  let currentAnimationTarget = axisBox();
  let isAnimating = { x: false, y: false };
  let stopAxisAnimation = { x: void 0, y: void 0 };
  let unsubLayoutReady;
  let isAnimatingTree = false;
  onMount(() => {
    visualElement2(visualElement2().animateMotionValue = startAnimation, true);
    visualElement2().enableLayoutProjection();
    unsubLayoutReady = visualElement2().onLayoutUpdate(animateF);
    visualElement2(
      visualElement2().layoutSafeToRemove = function() {
        safeToRemove()();
      },
      true
    );
    addScaleCorrection(defaultScaleCorrectors);
  });
  onDestroy(() => {
    unsubLayoutReady();
    eachAxis((axis) => {
      var _a;
      return (_a = stopAxisAnimation[axis]) == null ? void 0 : _a.call(stopAxisAnimation);
    });
  });
  const animateF = (target, origin, {
    originBox,
    targetBox,
    visibilityAction,
    shouldStackAnimate,
    onComplete,
    ...config
  } = {}) => {
    if (strict_equals(shouldStackAnimate, false)) {
      isAnimatingTree = false;
      return safeToRemove()();
    }
    if (isAnimatingTree && strict_equals(shouldStackAnimate, true, false)) {
      return;
    } else if (shouldStackAnimate) {
      isAnimatingTree = true;
    }
    origin = originBox || origin;
    target = targetBox || target;
    const boxHasMoved = hasMoved(origin, target);
    const animations2 = eachAxis((axis) => {
      if (strict_equals(layout(), "position")) {
        const targetLength = target[axis].max - target[axis].min;
        origin[axis].max = origin[axis].min + targetLength;
      }
      if (visualElement2().projection.isTargetLocked) {
        return;
      } else if (strict_equals(visibilityAction, void 0, false)) {
        visualElement2().setVisibility(strict_equals(visibilityAction, VisibilityAction.Show));
      } else if (boxHasMoved) {
        return animateAxis(axis, target[axis], origin[axis], config);
      } else {
        return visualElement2().setProjectionTargetAxis(axis, target[axis].min, target[axis].max);
      }
    });
    visualElement2().syncRender();
    return Promise.all(animations2).then(() => {
      isAnimatingTree = false;
      onComplete && onComplete();
      visualElement2().notifyLayoutAnimationComplete();
    });
  };
  const animateAxis = (axis, target, origin, { transition: _transition } = {}) => {
    var _a, _b;
    (_a = stopAxisAnimation[axis]) == null ? void 0 : _a.call(stopAxisAnimation);
    if (isAnimating[axis] && axisIsEqual(target, currentAnimationTarget[axis])) {
      return;
    }
    (_b = stopAxisAnimation[axis]) == null ? void 0 : _b.call(stopAxisAnimation);
    isAnimating[axis] = true;
    const _frameTarget = frameTarget[axis];
    const layoutProgress = visualElement2().getProjectionAnimationProgress()[axis];
    layoutProgress.clearListeners();
    layoutProgress.set(0);
    layoutProgress.set(0);
    const frame = () => {
      const p = layoutProgress.get() / progressTarget;
      tweenAxis(_frameTarget, origin, target, p);
      visualElement2().setProjectionTargetAxis(axis, _frameTarget.min, _frameTarget.max);
    };
    frame();
    const unsubscribeProgress = layoutProgress.onChange(frame);
    stopAxisAnimation[axis] = () => {
      isAnimating[axis] = false;
      layoutProgress.stop();
      unsubscribeProgress();
    };
    currentAnimationTarget[axis] = target;
    const layoutTransition = _transition || visualElement2().getDefaultTransition() || defaultLayoutTransition;
    const animation = startAnimation(strict_equals(axis, "x") ? "layoutX" : "layoutY", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, "layout")).then(stopAxisAnimation[axis]);
    return animation;
  };
  init();
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Animate = hmr(Animate, () => Animate[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Animate[HMR].source;
    set(Animate[HMR].source, module.default[HMR].original);
  });
}
var Animate_default = Animate;
mark_module_end(Animate);

// node_modules/svelte-motion/src/motion/features/layout/AnimateLayoutContextProvider.svelte
mark_module_start();
AnimateLayoutContextProvider[FILENAME] = "node_modules/svelte-motion/src/motion/features/layout/AnimateLayoutContextProvider.svelte";
function AnimateLayoutContextProvider($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, AnimateLayoutContextProvider);
  const [$$stores, $$cleanup] = setup_stores();
  const $presence = () => (validate_store(presence, "presence"), store_get(presence, "$presence", $$stores));
  let visualElement2 = prop($$props, "visualElement", 8), props = prop($$props, "props", 8), isCustom = prop($$props, "isCustom", 8);
  let tmp = props(), layout = mutable_source(tmp.layout);
  const presence = usePresence(isCustom());
  legacy_pre_effect(
    () => (get(layout), deep_read_state(props())),
    () => {
      (($$value) => set(layout, $$value.layout))(props());
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  Animate_default(node, {
    get visualElement() {
      return visualElement2();
    },
    get layout() {
      return get(layout);
    },
    get safeToRemove() {
      return $presence()[1];
    }
  });
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  AnimateLayoutContextProvider = hmr(AnimateLayoutContextProvider, () => AnimateLayoutContextProvider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AnimateLayoutContextProvider[HMR].source;
    set(AnimateLayoutContextProvider[HMR].source, module.default[HMR].original);
  });
}
var AnimateLayoutContextProvider_default = AnimateLayoutContextProvider;
mark_module_end(AnimateLayoutContextProvider);

// node_modules/svelte-motion/src/motion/features/layout/Measure.svelte
mark_module_start();
Measure[FILENAME] = "node_modules/svelte-motion/src/motion/features/layout/Measure.svelte";
function Measure($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Measure);
  let visualElement2 = prop($$props, "visualElement", 8), syncLayout = prop($$props, "syncLayout", 8), framerSyncLayout = prop($$props, "framerSyncLayout", 8), update = prop($$props, "update", 8);
  const scaleCorrectionContext = getContext(ScaleCorrectionContext);
  const scaleCorrectionParentContext = getContext(ScaleCorrectionParentContext);
  onMount(() => {
    isSharedLayout(syncLayout()) && syncLayout().register(visualElement2());
    isSharedLayout(framerSyncLayout()) && framerSyncLayout().register(visualElement2());
    visualElement2().onUnmount(() => {
      if (isSharedLayout(syncLayout())) {
        syncLayout().remove(visualElement2());
      }
      if (isSharedLayout(framerSyncLayout())) {
        framerSyncLayout().remove(visualElement2());
      }
    });
  });
  let updated = false;
  const updater = (nc = false) => {
    if (updated) {
      return null;
    }
    updated = true;
    get2(scaleCorrectionContext).forEach((v) => {
      var _a;
      (_a = v.updater) == null ? void 0 : _a.call(v, true);
    });
    if (isSharedLayout(syncLayout())) {
      syncLayout().syncUpdate();
    } else {
      snapshotViewportBox(visualElement2(), nc);
      syncLayout().add(visualElement2());
    }
    return null;
  };
  if (strict_equals(update(), void 0)) {
    beforeUpdate(updater);
  }
  const afterU = (nc = false) => {
    updated = false;
    const scc = get2(scaleCorrectionContext);
    scc.forEach((v, i) => {
      var _a;
      (_a = v.afterU) == null ? void 0 : _a.call(v, true);
    });
    if (!isSharedLayout(syncLayout())) {
      syncLayout().flush();
    }
  };
  scaleCorrectionParentContext.update((v) => v.concat([{ updater, afterU }]));
  afterUpdate(afterU);
  legacy_pre_effect(() => deep_read_state(update()), () => {
    strict_equals(update(), void 0, false) && updater(update());
  });
  legacy_pre_effect_reset();
  init();
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Measure = hmr(Measure, () => Measure[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Measure[HMR].source;
    set(Measure[HMR].source, module.default[HMR].original);
  });
}
var Measure_default = Measure;
mark_module_end(Measure);

// node_modules/svelte-motion/src/motion/features/layout/MeasureContextProvider.svelte
mark_module_start();
MeasureContextProvider[FILENAME] = "node_modules/svelte-motion/src/motion/features/layout/MeasureContextProvider.svelte";
function MeasureContextProvider($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, MeasureContextProvider);
  const [$$stores, $$cleanup] = setup_stores();
  const $syncLayout = () => (validate_store(syncLayout, "syncLayout"), store_get(syncLayout, "$syncLayout", $$stores));
  const $framerSyncLayout = () => (validate_store(framerSyncLayout, "framerSyncLayout"), store_get(framerSyncLayout, "$framerSyncLayout", $$stores));
  const update = mutable_source();
  let visualElement2 = prop($$props, "visualElement", 8), props = prop($$props, "props", 8), isCustom = prop($$props, "isCustom", 8);
  const syncLayout = getContext(SharedLayoutContext) || SharedLayoutContext(isCustom());
  const framerSyncLayout = getContext(FramerTreeLayoutContext) || FramerTreeLayoutContext(isCustom());
  legacy_pre_effect(
    () => (get(update), deep_read_state(props())),
    () => {
      (($$value) => set(update, $$value.update))(props());
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  Measure_default(node, {
    get syncLayout() {
      return $syncLayout();
    },
    get framerSyncLayout() {
      return $framerSyncLayout();
    },
    get visualElement() {
      return visualElement2();
    },
    get update() {
      return get(update);
    }
  });
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  MeasureContextProvider = hmr(MeasureContextProvider, () => MeasureContextProvider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MeasureContextProvider[HMR].source;
    set(MeasureContextProvider[HMR].source, module.default[HMR].original);
  });
}
var MeasureContextProvider_default = MeasureContextProvider;
mark_module_end(MeasureContextProvider);

// node_modules/svelte-motion/src/motion/features/layout/index.js
var layoutAnimations = {
  measureLayout: MeasureContextProvider_default,
  layoutAnimation: AnimateLayoutContextProvider_default
};

// node_modules/svelte-motion/src/motion/features/AnimationState.svelte
mark_module_start();
AnimationState[FILENAME] = "node_modules/svelte-motion/src/motion/features/AnimationState.svelte";
function AnimationState($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, AnimationState);
  let visualElement2 = prop($$props, "visualElement", 12), props = prop($$props, "props", 8);
  let tmp = props(), animate4 = mutable_source(tmp.animate);
  legacy_pre_effect(
    () => (get(animate4), deep_read_state(props())),
    () => {
      (($$value) => set(animate4, $$value.animate))(props());
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(visualElement2()), createAnimationState),
    () => {
      visualElement2(visualElement2().animationState = visualElement2().animationState || createAnimationState(visualElement2()), true);
    }
  );
  legacy_pre_effect(
    () => (isAnimationControls, get(animate4), tick, deep_read_state(visualElement2())),
    () => {
      if (isAnimationControls(get(animate4))) {
        tick().then(() => get(animate4).subscribe(visualElement2()));
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AnimationState = hmr(AnimationState, () => AnimationState[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AnimationState[HMR].source;
    set(AnimationState[HMR].source, module.default[HMR].original);
  });
}
var AnimationState_default = AnimationState;
mark_module_end(AnimationState);

// node_modules/svelte-motion/src/motion/features/Exit.svelte
mark_module_start();
Exit[FILENAME] = "node_modules/svelte-motion/src/motion/features/Exit.svelte";
function Exit($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Exit);
  const [$$stores, $$cleanup] = setup_stores();
  const $presenceContext = () => (validate_store(presenceContext, "presenceContext"), store_get(presenceContext, "$presenceContext", $$stores));
  const $presence = () => (validate_store(presence, "presence"), store_get(presence, "$presence", $$stores));
  const custom = mutable_source();
  let props = prop($$props, "props", 8), visualElement2 = prop($$props, "visualElement", 8), isCustom = prop($$props, "isCustom", 8);
  const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom());
  const presence = usePresence(isCustom());
  const effect = (pres) => {
    var _a, _b;
    const [isPresent2, onExitComplete] = pres;
    const animation = (_b = visualElement2().animationState) == null ? void 0 : _b.setActive(AnimationType.Exit, !isPresent2, {
      custom: ((_a = $presenceContext()) == null ? void 0 : _a.custom) ?? get(custom)
    });
    !isPresent2 && (animation == null ? void 0 : animation.then(onExitComplete));
    return "";
  };
  legacy_pre_effect(
    () => (get(custom), deep_read_state(props())),
    () => {
      (($$value) => set(custom, $$value.custom))(props());
    }
  );
  legacy_pre_effect(() => $presence(), () => {
    effect($presence());
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Exit = hmr(Exit, () => Exit[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Exit[HMR].source;
    set(Exit[HMR].source, module.default[HMR].original);
  });
}
var Exit_default = Exit;
mark_module_end(Exit);

// node_modules/svelte-motion/src/motion/features/animations.js
var animations = {
  animation: AnimationState_default,
  exit: Exit_default
};

// node_modules/svelte-motion/src/render/dom/featureBundle.js
var featureBundle = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layoutAnimations
};

// node_modules/svelte-motion/src/render/dom/motion.js
var motion = (
  //createMotionProxy(allMotionFeatures);
  createMotionClass(featureBundle)
);

// node_modules/svelte-motion/src/render/svg/lowercase-elements.js
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "tspan",
  "use",
  "view"
];

// node_modules/svelte-motion/src/render/dom/utils/is-svg-component.js
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component)
  ) {
    return true;
  }
  return false;
}

// node_modules/svelte-motion/src/render/dom/M.svelte
mark_module_start();
M[FILENAME] = "node_modules/svelte-motion/src/render/dom/M.svelte";
function M($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["___tag"]);
  push($$props, false, M);
  let ___tag = prop($$props, "___tag", 8);
  var fragment = comment();
  var node = first_child(fragment);
  Motion_default(node, spread_props(() => $$restProps, {
    children: invalid_default_snippet,
    $$slots: {
      default: ($$anchor2, $$slotProps) => {
        const props = derived_safe_equal(() => $$slotProps.props);
        const motion2 = derived_safe_equal(() => $$slotProps.motion);
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        validate_void_dynamic_element(___tag);
        validate_dynamic_element_tag(___tag);
        element(
          node_1,
          ___tag,
          false,
          ($$element, $$anchor3) => {
            action($$element, ($$node) => {
              var _a;
              return (_a = get(motion2)) == null ? void 0 : _a($$node);
            });
            let attributes;
            template_effect(() => attributes = set_attributes($$element, attributes, { ...get(props) }));
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            slot(node_2, $$props, "default", {}, null);
            append($$anchor3, fragment_2);
          },
          void 0,
          [7, 4]
        );
        append($$anchor2, fragment_1);
      }
    }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  M = hmr(M, () => M[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = M[HMR].source;
    set(M[HMR].source, module.default[HMR].original);
  });
}
var M_default = M;
mark_module_end(M);

// node_modules/svelte-motion/src/render/dom/motion-proxy.js
function createMotionProxy(defaultFeatures) {
  return new Proxy({}, {
    /**
     * Called when `motion` is referenced with a prop: `MotionDiv`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: function(_target, key) {
      let type = key;
      if (key.slice(0, 1) === key.slice(0, 1).toLowerCase()) {
        type = isSVGComponent(key) ? "SVG" : "DOM";
      }
      const ret = new Proxy(M_default, {
        construct(target, args) {
          if (!args || !args[0]) {
            args.push({});
          }
          if (!args[0].props) {
            args[0].props = { ___tag: key, isSVG: type === "SVG" };
          } else {
            args[0].props.___tag = key;
            args[0].props.isSVG = type === "SVG";
          }
          return new target(...args);
        }
      });
      return ret;
    }
  });
}
var M2 = createMotionProxy();

// node_modules/svelte-motion/src/motion/MotionSSR.svelte
mark_module_start();
MotionSSR[FILENAME] = "node_modules/svelte-motion/src/motion/MotionSSR.svelte";
var root_52 = add_locations(template(`<!> <!>`, 1), MotionSSR[FILENAME], []);
function MotionSSR($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "isSVG",
    "forwardMotionProps",
    "externalRef",
    "targetEl"
  ]);
  push($$props, false, MotionSSR);
  const [$$stores, $$cleanup] = setup_stores();
  const $a = () => (validate_store(a, "a"), store_get(a, "$a", $$stores));
  const motionProps = mutable_source();
  const isStatic = mutable_source();
  let isSVG = prop($$props, "isSVG", 8, false), forwardMotionProps = prop($$props, "forwardMotionProps", 8, false), externalRef = prop($$props, "externalRef", 8, void 0), targetEl = prop($$props, "targetEl", 8, void 0);
  loadFeatures(featureBundle);
  let Component = isSVG() ? "SVG" : "DOM";
  let isCustom = targetEl() || false;
  let createVisualElement = createDomVisualElement;
  let visualStateConfig = isSVG() ? svgMotionConfig : htmlMotionConfig;
  const a = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  let mounted = mutable_source(false);
  const setContext2 = (c, v) => {
    c.visualElement = v;
    return v;
  };
  onMount(() => {
    set(mounted, true);
  });
  legacy_pre_effect(() => deep_read_state($$restProps), () => {
    set(motionProps, $$restProps);
  });
  legacy_pre_effect(() => (get(isStatic), $a()), () => {
    (($$value) => set(isStatic, $$value.isStatic))($a() || {});
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  ScaleCorrectionProvider_default(node, {
    isCustom,
    children: wrap_snippet(MotionSSR, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      UseCreateMotionContext_default(node_1, {
        get props() {
          return get(motionProps);
        },
        get isStatic() {
          return get(isStatic);
        },
        children: invalid_default_snippet,
        $$slots: {
          default: ($$anchor3, $$slotProps2) => {
            const context = derived_safe_equal(() => $$slotProps2.value);
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            UseVisualState_default(node_2, {
              config: visualStateConfig,
              get props() {
                return get(motionProps);
              },
              get isStatic() {
                return get(isStatic);
              },
              isCustom,
              children: invalid_default_snippet,
              $$slots: {
                default: ($$anchor4, $$slotProps3) => {
                  const visualState = derived_safe_equal(() => $$slotProps3.state);
                  var fragment_3 = comment();
                  var node_3 = first_child(fragment_3);
                  UseVisualElement_default(node_3, {
                    Component,
                    get visualState() {
                      return get(visualState);
                    },
                    createVisualElement,
                    get props() {
                      return get(motionProps);
                    },
                    isCustom,
                    children: invalid_default_snippet,
                    $$slots: {
                      default: ($$anchor5, $$slotProps4) => {
                        const visualElement2 = derived_safe_equal(() => $$slotProps4.visualElement);
                        var fragment_4 = comment();
                        var node_4 = first_child(fragment_4);
                        const expression = derived_safe_equal(() => setContext2(get(context), get(visualElement2)));
                        UseFeatures_default(node_4, {
                          get visualElement() {
                            return get(expression);
                          },
                          get props() {
                            return get(motionProps);
                          },
                          children: invalid_default_snippet,
                          $$slots: {
                            default: ($$anchor6, $$slotProps5) => {
                              const _features = derived_safe_equal(() => $$slotProps5.features);
                              var fragment_5 = root_52();
                              var node_5 = first_child(fragment_5);
                              MotionContextProvider_default(node_5, {
                                get value() {
                                  return get(context);
                                },
                                isCustom,
                                children: wrap_snippet(MotionSSR, ($$anchor7, $$slotProps6) => {
                                  var fragment_6 = comment();
                                  var node_6 = first_child(fragment_6);
                                  const expression_1 = derived_safe_equal(() => useMotionRef(get(visualState), get(context).visualElement, externalRef()));
                                  UseRender_default(node_6, {
                                    Component,
                                    get props() {
                                      return get(motionProps);
                                    },
                                    get ref() {
                                      return get(expression_1);
                                    },
                                    get visualState() {
                                      return get(visualState);
                                    },
                                    get isStatic() {
                                      return get(isStatic);
                                    },
                                    get forwardMotionProps() {
                                      return forwardMotionProps();
                                    },
                                    get targetEl() {
                                      return targetEl();
                                    },
                                    children: invalid_default_snippet,
                                    $$slots: {
                                      default: ($$anchor8, $$slotProps7) => {
                                        const motion2 = derived_safe_equal(() => $$slotProps7.motion);
                                        const renderProps = derived_safe_equal(() => $$slotProps7.props);
                                        var fragment_7 = comment();
                                        var node_7 = first_child(fragment_7);
                                        slot(
                                          node_7,
                                          $$props,
                                          "default",
                                          {
                                            get motion() {
                                              return get(motion2);
                                            },
                                            get props() {
                                              return get(renderProps);
                                            }
                                          },
                                          null
                                        );
                                        append($$anchor8, fragment_7);
                                      }
                                    }
                                  });
                                  append($$anchor7, fragment_6);
                                }),
                                $$slots: { default: true }
                              });
                              var node_8 = sibling(node_5, 2);
                              {
                                var consequent = ($$anchor7) => {
                                  var fragment_8 = comment();
                                  var node_9 = first_child(fragment_8);
                                  validate_each_keys(() => get(_features), (feat) => feat.key);
                                  each(node_9, 1, () => get(_features), (feat) => feat.key, ($$anchor8, feat) => {
                                    var fragment_9 = comment();
                                    var node_10 = first_child(fragment_9);
                                    component(node_10, () => get(feat).Component, ($$anchor9, $$component) => {
                                      $$component($$anchor9, {
                                        get props() {
                                          return get(feat).props;
                                        },
                                        get visualElement() {
                                          return get(feat).visualElement;
                                        },
                                        isCustom
                                      });
                                    });
                                    append($$anchor8, fragment_9);
                                  });
                                  append($$anchor7, fragment_8);
                                };
                                if_block(node_8, ($$render) => {
                                  if (get(mounted)) $$render(consequent);
                                });
                              }
                              append($$anchor6, fragment_5);
                            }
                          }
                        });
                        append($$anchor5, fragment_4);
                      }
                    }
                  });
                  append($$anchor4, fragment_3);
                }
              }
            });
            append($$anchor3, fragment_2);
          }
        }
      });
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  MotionSSR = hmr(MotionSSR, () => MotionSSR[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MotionSSR[HMR].source;
    set(MotionSSR[HMR].source, module.default[HMR].original);
  });
}
var MotionSSR_default = MotionSSR;
mark_module_end(MotionSSR);

// node_modules/svelte-motion/src/components/AnimatePresence/PresenceChild.svelte
mark_module_start();
PresenceChild[FILENAME] = "node_modules/svelte-motion/src/components/AnimatePresence/PresenceChild.svelte";
var presenceId = 0;
function getPresenceId() {
  const id = presenceId;
  presenceId++;
  return id;
}
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function PresenceChild($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, PresenceChild);
  const refresh = mutable_source();
  let isPresent2 = prop($$props, "isPresent", 8), onExitComplete = prop($$props, "onExitComplete", 8, void 0), initial = prop($$props, "initial", 8), custom = prop($$props, "custom", 8, void 0), presenceAffectsLayout = prop($$props, "presenceAffectsLayout", 8), isCustom = prop($$props, "isCustom", 8);
  const presenceChildren = new newChildrenMap();
  const id = getPresenceId();
  const memoContext = () => {
    return {
      id,
      initial: initial(),
      isPresent: isPresent2(),
      custom: custom(),
      onExitComplete: (childId) => {
        var _a;
        presenceChildren.set(childId, true);
        let allComplete = true;
        presenceChildren.forEach((isComplete) => {
          if (!isComplete) allComplete = false;
        });
        allComplete && ((_a = onExitComplete()) == null ? void 0 : _a());
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    };
  };
  let context = PresenceContext();
  afterUpdate(() => {
    if (presenceAffectsLayout()) {
      context.set(memoContext());
    }
  });
  const keyset = () => {
    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
  };
  setContext(PresenceContext, context);
  setDomContext("Presence", isCustom(), context);
  legacy_pre_effect(
    () => (deep_read_state(presenceAffectsLayout()), deep_read_state(isPresent2())),
    () => {
      set(refresh, presenceAffectsLayout() ? void 0 : isPresent2());
    }
  );
  legacy_pre_effect(() => get(refresh), () => {
    context.set(memoContext(get(refresh)));
  });
  legacy_pre_effect(() => deep_read_state(isPresent2()), () => {
    keyset(isPresent2());
  });
  legacy_pre_effect(
    () => (tick, deep_read_state(isPresent2()), deep_read_state(onExitComplete())),
    () => {
      tick().then(() => {
        var _a;
        !isPresent2() && !presenceChildren.size && ((_a = onExitComplete()) == null ? void 0 : _a());
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PresenceChild = hmr(PresenceChild, () => PresenceChild[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PresenceChild[HMR].source;
    set(PresenceChild[HMR].source, module.default[HMR].original);
  });
}
var PresenceChild_default = PresenceChild;
mark_module_end(PresenceChild);

// node_modules/svelte-motion/src/components/AnimatePresence/AnimatePresence.svelte
mark_module_start();
AnimatePresence[FILENAME] = "node_modules/svelte-motion/src/components/AnimatePresence/AnimatePresence.svelte";
function AnimatePresence($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, AnimatePresence);
  const [$$stores, $$cleanup] = setup_stores();
  const $layoutContext = () => (validate_store(layoutContext, "layoutContext"), store_get(layoutContext, "$layoutContext", $$stores));
  const isl = mutable_source();
  const forceRender = mutable_source();
  let list = prop($$props, "list", 8, void 0), custom = prop($$props, "custom", 8, void 0), initial = prop($$props, "initial", 8, true), onExitComplete = prop($$props, "onExitComplete", 8, void 0), exitBeforeEnter = prop($$props, "exitBeforeEnter", 8, void 0), presenceAffectsLayout = prop($$props, "presenceAffectsLayout", 8, true), show = prop($$props, "show", 8, void 0), isCustom = prop($$props, "isCustom", 8, false);
  let _list = mutable_source(strict_equals(list(), void 0, false) ? list() : show() ? [{ key: 1 }] : []);
  const layoutContext = getContext(SharedLayoutContext) || SharedLayoutContext(isCustom());
  function getChildKey(child2) {
    return child2.key || "";
  }
  let isInitialRender = mutable_source(true);
  let filteredChildren = mutable_source(get(_list));
  let presentChildren = mutable_source(get(filteredChildren));
  let allChildren = /* @__PURE__ */ new Map();
  let exiting = /* @__PURE__ */ new Set();
  const updateChildLookup = (children, allChild) => {
    children.forEach((child2) => {
      const key = getChildKey(child2);
      allChild.set(key, child2);
    });
  };
  let childrenToRender = mutable_source([
    ...get(filteredChildren).map((v) => ({ present: true, item: v, key: v.key }))
  ]);
  legacy_pre_effect(
    () => (deep_read_state(list()), deep_read_state(show())),
    () => {
      set(_list, strict_equals(list(), void 0, false) ? list() : show() ? [{ key: 1 }] : []);
    }
  );
  legacy_pre_effect(() => (isSharedLayout, $layoutContext()), () => {
    set(isl, isSharedLayout($layoutContext()));
  });
  legacy_pre_effect(
    () => (get(isl), $layoutContext(), get(_list)),
    () => {
      set(forceRender, () => {
        if (get(isl)) {
          $layoutContext().forceUpdate();
        }
        set(_list, [...get(_list)]);
      });
    }
  );
  legacy_pre_effect(() => get(_list), () => {
    set(filteredChildren, get(_list));
  });
  legacy_pre_effect(() => get(filteredChildren), () => {
    updateChildLookup(get(filteredChildren), allChildren);
  });
  legacy_pre_effect(
    () => (get(isInitialRender), get(childrenToRender), get(filteredChildren), get(presentChildren), deep_read_state(exitBeforeEnter()), get(forceRender), deep_read_state(onExitComplete())),
    () => {
      if (!get(isInitialRender)) {
        set(childrenToRender, [
          ...get(filteredChildren).map((v) => ({ present: true, item: v, key: v.key }))
        ]);
        const presentKeys = get(presentChildren).map(getChildKey);
        const targetKeys = get(filteredChildren).map(getChildKey);
        const numPresent = presentKeys.length;
        for (let i = 0; i < numPresent; i++) {
          const key = presentKeys[i];
          if (strict_equals(targetKeys.indexOf(key), -1)) {
            exiting.add(key);
          } else {
            exiting.delete(key);
          }
        }
        if (exitBeforeEnter() && exiting.size) {
          set(childrenToRender, []);
        }
        exiting.forEach((key) => {
          if (strict_equals(targetKeys.indexOf(key), -1, false)) return;
          const child2 = allChildren.get(key);
          if (!child2) return;
          const insertionIndex = presentKeys.indexOf(key);
          const onExit = () => {
            allChildren.delete(key);
            exiting.delete(key);
            const removeIndex = get(presentChildren).findIndex((presentChild) => strict_equals(presentChild.key, key));
            if (removeIndex < 0) {
              return;
            }
            get(presentChildren).splice(removeIndex, 1);
            if (!exiting.size) {
              set(presentChildren, [...get(filteredChildren)]);
              get(forceRender)();
              onExitComplete() && onExitComplete()();
            }
          };
          get(childrenToRender).splice(insertionIndex, 0, {
            present: false,
            item: child2,
            key: getChildKey(child2),
            onExit
          });
        });
        set(presentChildren, get(childrenToRender));
      } else {
        set(isInitialRender, false);
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  validate_each_keys(() => get(childrenToRender), (child2) => getChildKey(child2));
  each(node, 1, () => get(childrenToRender), (child2) => getChildKey(child2), ($$anchor2, child2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    const expression = derived_safe_equal(() => initial() ? void 0 : false);
    const expression_1 = derived_safe_equal(() => get(child2).onExit ? custom() : void 0);
    PresenceChild_default(node_1, {
      get isPresent() {
        return get(child2).present;
      },
      get initial() {
        return get(expression);
      },
      get custom() {
        return get(expression_1);
      },
      get presenceAffectsLayout() {
        return presenceAffectsLayout();
      },
      get onExitComplete() {
        return get(child2).onExit;
      },
      get isCustom() {
        return isCustom();
      },
      children: wrap_snippet(AnimatePresence, ($$anchor3, $$slotProps) => {
        var fragment_2 = comment();
        var node_2 = first_child(fragment_2);
        slot(
          node_2,
          $$props,
          "default",
          {
            get item() {
              return get(child2).item;
            }
          },
          null
        );
        append($$anchor3, fragment_2);
      }),
      $$slots: { default: true }
    });
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  AnimatePresence = hmr(AnimatePresence, () => AnimatePresence[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AnimatePresence[HMR].source;
    set(AnimatePresence[HMR].source, module.default[HMR].original);
  });
}
var AnimatePresence_default = AnimatePresence;
mark_module_end(AnimatePresence);

// node_modules/svelte-motion/src/animation/animate.js
function animate2(from, to, transition) {
  if (transition === void 0) {
    transition = {};
  }
  var value = isMotionValue(from) ? from : motionValue(from);
  startAnimation("", value, to, transition);
  return {
    stop: function() {
      return value.stop();
    }
  };
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/crossfader.js
import sync7, { getFrameData as getFrameData3 } from "framesync";
import { mix as mix6, progress as progress3, linear as linear2, mixColor, circOut as circOut2 } from "popmotion";
function createCrossfader() {
  var progress4 = motionValue(1);
  var options = {
    lead: void 0,
    follow: void 0,
    crossfadeOpacity: false,
    preserveFollowOpacity: false
  };
  var prevOptions = Object.assign({}, options);
  var leadState = {};
  var followState = {};
  var isActive = false;
  var finalCrossfadeFrame = null;
  var prevUpdate = 0;
  function startCrossfadeAnimation(target, transition) {
    var lead = options.lead, follow = options.follow;
    isActive = true;
    finalCrossfadeFrame = null;
    var hasUpdated = false;
    var onUpdate = function() {
      hasUpdated = true;
      lead && lead.scheduleRender();
      follow && follow.scheduleRender();
    };
    var onComplete = function() {
      isActive = false;
      finalCrossfadeFrame = getFrameData3().timestamp;
    };
    transition = transition && getValueTransition(transition, "crossfade");
    return animate2(progress4, target, Object.assign(Object.assign({}, transition), { onUpdate, onComplete: function() {
      if (!hasUpdated) {
        progress4.set(target);
        sync7.read(onComplete);
      } else {
        onComplete();
      }
      onUpdate();
    } }));
  }
  function updateCrossfade() {
    var _a, _b;
    var timestamp = getFrameData3().timestamp;
    var lead = options.lead, follow = options.follow;
    if (timestamp === prevUpdate || !lead)
      return;
    prevUpdate = timestamp;
    var latestLeadValues = lead.getLatestValues();
    Object.assign(leadState, latestLeadValues);
    var latestFollowValues = follow ? follow.getLatestValues() : options.prevValues;
    Object.assign(followState, latestFollowValues);
    var p = progress4.get();
    var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;
    var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;
    if (options.crossfadeOpacity && follow) {
      leadState.opacity = mix6(
        /**
         * If the follow child has been completely hidden we animate
         * this opacity from its previous opacity, but otherwise from completely transparent.
         */
        follow.isVisible !== false ? 0 : followTargetOpacity,
        leadTargetOpacity,
        easeCrossfadeIn(p)
      );
      followState.opacity = options.preserveFollowOpacity ? followTargetOpacity : mix6(followTargetOpacity, 0, easeCrossfadeOut(p));
    } else if (!follow) {
      leadState.opacity = mix6(followTargetOpacity, leadTargetOpacity, p);
    }
    mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);
  }
  return {
    isActive: function() {
      return leadState && (isActive || getFrameData3().timestamp === finalCrossfadeFrame);
    },
    fromLead: function(transition) {
      return startCrossfadeAnimation(0, transition);
    },
    toLead: function(transition) {
      var initialProgress = 0;
      if (!options.prevValues && !options.follow) {
        initialProgress = 1;
      } else if (prevOptions.lead === options.follow && prevOptions.follow === options.lead) {
        initialProgress = 1 - progress4.get();
      }
      progress4.set(initialProgress);
      return startCrossfadeAnimation(1, transition);
    },
    reset: function() {
      return progress4.set(1);
    },
    stop: function() {
      return progress4.stop();
    },
    getCrossfadeState: function(element2) {
      updateCrossfade();
      if (element2 === options.lead) {
        return leadState;
      } else if (element2 === options.follow) {
        return followState;
      }
    },
    setOptions: function(newOptions) {
      prevOptions = options;
      options = newOptions;
      leadState = {};
      followState = {};
    },
    getLatestValues: function() {
      return leadState;
    }
  };
}
var easeCrossfadeIn = compress(0, 0.5, circOut2);
var easeCrossfadeOut = compress(0.5, 0.95, linear2);
function compress(min, max, easing) {
  return function(p) {
    if (p < min)
      return 0;
    if (p > max)
      return 1;
    return easing(progress3(min, max, p));
  };
}
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
function mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {
  for (var i = 0; i < numBorders; i++) {
    var borderLabel = "border" + borders[i] + "Radius";
    var followRadius = getRadius(latestFollowValues, borderLabel);
    var leadRadius = getRadius(latestLeadValues, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    if (typeof followRadius === "number" && typeof leadRadius === "number") {
      var radius = Math.max(mix6(followRadius, leadRadius, p), 0);
      leadState[borderLabel] = followState[borderLabel] = radius;
    }
  }
  if (latestFollowValues.rotate || latestLeadValues.rotate) {
    var rotate = mix6(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);
    leadState.rotate = followState.rotate = rotate;
  }
  if (!hasFollowElement && latestLeadValues.backgroundColor && latestFollowValues.backgroundColor) {
    leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);
  }
}
function getRadius(values, radiusName) {
  var _a;
  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/stack.js
function layoutStack() {
  var stack = /* @__PURE__ */ new Set();
  var state = { leadIsExiting: false };
  var prevState = Object.assign({}, state);
  var prevValues;
  var prevViewportBox;
  var prevDragCursor;
  var crossfader = createCrossfader();
  var needsCrossfadeAnimation = false;
  function getFollowViewportBox() {
    return state.follow ? state.follow.prevViewportBox : prevViewportBox;
  }
  function getFollowLayout() {
    var _a;
    return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;
  }
  return {
    add: function(element2) {
      element2.setCrossfader(crossfader);
      stack.add(element2);
      if (prevDragCursor)
        element2.prevDragCursor = prevDragCursor;
      if (!state.lead)
        state.lead = element2;
    },
    remove: function(element2) {
      stack.delete(element2);
    },
    getLead: function() {
      return state.lead;
    },
    updateSnapshot: function() {
      if (!state.lead)
        return;
      prevValues = crossfader.isActive() ? crossfader.getLatestValues() : state.lead.getLatestValues();
      prevViewportBox = state.lead.prevViewportBox;
      var dragControls = elementDragControls.get(state.lead);
      if (dragControls && dragControls.isDragging) {
        prevDragCursor = dragControls.cursorProgress;
      }
    },
    clearSnapshot: function() {
      prevDragCursor = prevViewportBox = void 0;
    },
    updateLeadAndFollow: function() {
      var _a;
      prevState = Object.assign({}, state);
      var lead;
      var follow;
      var order2 = Array.from(stack);
      for (var i = order2.length; i--; i >= 0) {
        var element2 = order2[i];
        if (lead)
          follow !== null && follow !== void 0 ? follow : follow = element2;
        lead !== null && lead !== void 0 ? lead : lead = element2;
        if (lead && follow)
          break;
      }
      state.lead = lead;
      state.follow = follow;
      state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;
      crossfader.setOptions({
        lead,
        follow,
        prevValues,
        crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot)
      });
      if (
        // Don't crossfade if we've just animated back from lead and switched the
        // old follow to the new lead.
        state.lead !== prevState.follow && (prevState.lead !== state.lead || prevState.leadIsExiting !== state.leadIsExiting)
      ) {
        needsCrossfadeAnimation = true;
      }
    },
    animate: function(child2, shouldCrossfade) {
      var _a;
      if (shouldCrossfade === void 0) {
        shouldCrossfade = false;
      }
      if (child2 === state.lead) {
        if (shouldCrossfade) {
          child2.pointTo(state.lead);
        } else {
          child2.setVisibility(true);
        }
        var config = {};
        var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();
        if (prevParent) {
          config.prevParent = prevParent;
        }
        if (child2.presence === Presence.Entering) {
          config.originBox = getFollowViewportBox();
        } else if (child2.presence === Presence.Exiting) {
          config.targetBox = getFollowLayout();
        }
        if (needsCrossfadeAnimation) {
          needsCrossfadeAnimation = false;
          var transition = child2.getDefaultTransition();
          child2.presence === Presence.Entering ? crossfader.toLead(transition) : crossfader.fromLead(transition);
        }
        child2.notifyLayoutReady(config);
      } else {
        if (shouldCrossfade) {
          state.lead && child2.pointTo(state.lead);
        } else {
          child2.setVisibility(false);
        }
      }
    }
  };
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/rotate.js
function resetRotate(child2) {
  var hasRotate = false;
  var resetValues = {};
  for (var i = 0; i < transformAxes.length; i++) {
    var axis = transformAxes[i];
    var key = "rotate" + axis;
    if (!child2.hasValue(key) || child2.getStaticValue(key) === 0)
      continue;
    hasRotate = true;
    resetValues[key] = child2.getStaticValue(key);
    child2.setStaticValue(key, 0);
  }
  if (!hasRotate)
    return;
  child2.syncRender();
  for (var key in resetValues) {
    child2.setStaticValue(key, resetValues[key]);
  }
  child2.scheduleRender();
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/AnimateSharedLayout.svelte
mark_module_start();
AnimateSharedLayout[FILENAME] = "node_modules/svelte-motion/src/components/AnimateSharedLayout/AnimateSharedLayout.svelte";
function AnimateSharedLayout($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, AnimateSharedLayout);
  let type = prop($$props, "type", 8, void 0), isCustom = prop($$props, "isCustom", 8, false);
  const context = getContext(MotionContext) || MotionContext(isCustom());
  let hasMounted = false;
  let children = /* @__PURE__ */ new Set();
  let stacks = /* @__PURE__ */ new Map();
  let updateScheduled = false;
  let renderScheduled = mutable_source(false);
  let forced = false;
  let syncContext = {
    ...createBatcher(),
    syncUpdate: (force) => scheduleUpdate(force),
    forceUpdate: () => {
      scheduleUpdate();
      forced = true;
    },
    register: (child2) => addChild(child2),
    remove: (child2) => {
      removeChild(child2);
    }
  };
  const startLayoutAnimation = () => {
    set(renderScheduled, updateScheduled = false);
    children.forEach((child2) => {
      if (!child2.isPresent) {
        child2.presence = Presence.Exiting;
      } else if (strict_equals(child2.presence, Presence.Entering, false)) {
        child2.presence = strict_equals(child2.presence, Presence.Exiting) ? Presence.Entering : Presence.Present;
      }
    });
    updateStacks();
    const handler = {
      measureLayout: (child2) => child2.updateLayoutMeasurement(),
      layoutReady: (child2) => {
        if (strict_equals(child2.getLayoutId(), void 0, false)) {
          const stack = getStack(child2);
          stack.animate(child2, strict_equals(type(), "crossfade"));
        } else {
          child2.notifyLayoutReady();
        }
      },
      parent: get2(context).visualElement
    };
    children.forEach((child2) => syncContext.add(child2));
    syncContext.flush(handler);
    stacks.forEach((stack) => stack.clearSnapshot());
  };
  const updateStacks = () => {
    stacks.forEach((stack) => stack.updateLeadAndFollow());
  };
  const scheduleUpdate = (force = false) => {
    if (!(force || !updateScheduled)) return;
    updateScheduled = true;
    children.forEach((child2) => resetRotate(child2));
    children.forEach((child2) => snapshotViewportBox(child2));
    stacks.forEach((stack) => stack.updateSnapshot());
    if (force || !get(renderScheduled)) {
      set(renderScheduled, true);
      forced = true;
    }
  };
  const addChild = (child2) => {
    children.add(child2);
    addToStack(child2);
    child2.presence = hasMounted ? Presence.Entering : Presence.Present;
  };
  const removeChild = (child2) => {
    scheduleUpdate();
    children.delete(child2);
    removeFromStack(child2);
  };
  const addToStack = (child2) => {
    const stack = getStack(child2);
    stack == null ? void 0 : stack.add(child2);
  };
  const removeFromStack = (child2) => {
    const stack = getStack(child2);
    stack == null ? void 0 : stack.remove(child2);
  };
  const getStack = (child2) => {
    const id = child2.getLayoutId();
    if (strict_equals(id, void 0)) return;
    !stacks.has(id) && stacks.set(id, layoutStack());
    return stacks.get(id);
  };
  let sc = writable(syncContext);
  const setSyncContext = () => {
    syncContext = { ...syncContext };
    sc.set(syncContext);
  };
  setContext(SharedLayoutContext, sc);
  setDomContext("SharedLayout", isCustom(), sc);
  onMount(() => {
    hasMounted = true;
  });
  legacy_pre_effect(() => (get(renderScheduled), tick), () => {
    if (get(renderScheduled)) {
      tick().then(() => {
        startLayoutAnimation();
      });
    }
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AnimateSharedLayout = hmr(AnimateSharedLayout, () => AnimateSharedLayout[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AnimateSharedLayout[HMR].source;
    set(AnimateSharedLayout[HMR].source, module.default[HMR].original);
  });
}
var AnimateSharedLayout_default = AnimateSharedLayout;
mark_module_end(AnimateSharedLayout);

// node_modules/svelte-motion/src/value/use-combine-values.js
import sync8 from "framesync";
var useCombineMotionValues = (values, combineValues) => {
  let subscriptions = [];
  let vals = values;
  const unsubscribe = () => {
    subscriptions.forEach((unsubscribe2) => unsubscribe2());
  };
  const subscribe = () => {
    subscriptions = vals.map((val) => val.onChange(handler));
    updateValue();
  };
  const value = motionValue(combineValues(), () => {
    unsubscribe();
    subscribe();
    return unsubscribe;
  });
  let updateValue = () => {
    value.set(combineValues());
  };
  const handler = () => {
    sync8.update(updateValue, false, true);
  };
  value.reset = (_values, _combineValues) => {
    vals = _values;
    unsubscribe();
    updateValue = () => {
      value.set(_combineValues());
    };
    subscribe();
  };
  return value;
};

// node_modules/svelte-motion/src/value/use-motion-template.js
var useMotionTemplate = (fragments, ...values) => {
  let numFragments = fragments.length;
  const buildValue = () => {
    let output = ``;
    for (let i = 0; i < numFragments; i++) {
      output += fragments[i];
      const value2 = values[i];
      if (value2) output += values[i].get();
    }
    return output;
  };
  const value = useCombineMotionValues(values, buildValue);
  value.resetInner = value.reset;
  value.reset = (f, ...vs) => {
    numFragments = f.length;
    value.resetInner(vs, buildValue);
  };
  return value;
};

// node_modules/svelte-motion/src/utils/transform.js
import { interpolate } from "popmotion";
var isCustomValueType = function(v) {
  return typeof v === "object" && v.mix;
};
var getMixer = function(v) {
  return isCustomValueType(v) ? v.mix : void 0;
};
function transform() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var useImmediate = !Array.isArray(args[0]);
  var argOffset = useImmediate ? 0 : -1;
  var inputValue = args[0 + argOffset];
  var inputRange = args[1 + argOffset];
  var outputRange = args[2 + argOffset];
  var options = args[3 + argOffset];
  var interpolator = interpolate(inputRange, outputRange, Object.assign({ mixer: getMixer(outputRange[0]) }, options));
  return useImmediate ? interpolator(inputValue) : interpolator;
}

// node_modules/svelte-motion/src/value/use-transform.js
var useTransform = (input, inputRangeOrTransformer, outputRange, options) => {
  let latest = [];
  const update = (input2, inputRangeOrTransformer2, outputRange2, options2) => {
    const transformer = typeof inputRangeOrTransformer2 === "function" ? inputRangeOrTransformer2 : transform(inputRangeOrTransformer2, outputRange2, options2);
    const values = Array.isArray(input2) ? input2 : [input2];
    const _transformer = Array.isArray(input2) ? transformer : ([latest2]) => transformer(latest2);
    return [values, () => {
      latest.length = 0;
      const numValues = values.length;
      for (let i = 0; i < numValues; i++) {
        latest[i] = values[i].get();
      }
      return _transformer(latest);
    }];
  };
  const comb = useCombineMotionValues(...update(
    input,
    inputRangeOrTransformer,
    outputRange,
    options
  ));
  comb.updateInner = comb.reset;
  comb.reset = (input2, inputRangeOrTransformer2, outputRange2, options2) => comb.updateInner(
    ...update(
      input2,
      inputRangeOrTransformer2,
      outputRange2,
      options2
    )
  );
  return comb;
};

// node_modules/svelte-motion/src/value/use-spring.js
import { animate as animate3 } from "popmotion";
var useSpring = (source, config = {}, isCustom = false) => {
  const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  let activeSpringAnimation = null;
  let value = motionValue(isMotionValue(source) ? source.get() : source);
  let cleanup;
  const update = (_source, _config) => {
    value.attach((v, set2) => {
      const { isStatic } = get2(mcc);
      if (isStatic) {
        return set2(v);
      }
      if (activeSpringAnimation) {
        activeSpringAnimation.stop();
      }
      activeSpringAnimation = animate3({
        from: value.get(),
        to: v,
        velocity: value.getVelocity(),
        ..._config,
        onUpdate: set2
      });
      return value.get();
    });
    cleanup == null ? void 0 : cleanup();
    return isMotionValue(_source) ? _source.onChange((v) => value.set(parseFloat(v))) : void 0;
  };
  update(source, config);
  value.reset = update;
  return value;
};

// node_modules/svelte-motion/src/value/scroll/utils.js
function createScrollMotionValues(startStopNotifier) {
  const hasListener = { x: false, y: false, xp: false, yp: false };
  let stop;
  const jointNotifier = startStopNotifier ? (type) => () => {
    if (!hasListener.x && !hasListener.y && !hasListener.xp && !hasListener.yp) {
      stop = startStopNotifier();
    }
    hasListener[type] = true;
    return () => {
      hasListener[type] = false;
      if (!hasListener.x && !hasListener.y && !hasListener.xp && !hasListener.yp) {
        if (stop) {
          stop.then((v) => v());
        }
      }
    };
  } : () => () => {
  };
  const smvs = {
    scrollX: motionValue(0, jointNotifier("x")),
    scrollY: motionValue(0, jointNotifier("y")),
    scrollXProgress: motionValue(0, jointNotifier("xp")),
    scrollYProgress: motionValue(0, jointNotifier("yp"))
  };
  return smvs;
}
function setProgress(offset, maxOffset, value) {
  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);
}
function createScrollUpdater(values, getOffsets) {
  var update = function() {
    var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;
    values.scrollX.set(xOffset);
    values.scrollY.set(yOffset);
    setProgress(xOffset, xMaxOffset, values.scrollXProgress);
    setProgress(yOffset, yMaxOffset, values.scrollYProgress);
  };
  update();
  return update;
}

// node_modules/svelte-motion/src/value/scroll/use-element-scroll.js
var getElementScrollOffsets = (element2) => () => {
  return {
    xOffset: element2.scrollLeft,
    yOffset: element2.scrollTop,
    xMaxOffset: element2.scrollWidth - element2.offsetWidth,
    yMaxOffset: element2.scrollHeight - element2.offsetHeight
  };
};
var useElementScroll = (ref) => {
  const values = {};
  const setScroll = async () => {
    if (typeof window === "undefined") return () => {
    };
    let times = 10;
    while ((!ref || !ref.current) && !values.ref) {
      if (times-- < 1) {
        return () => {
        };
      }
      ;
      await new Promise((r) => setTimeout(() => r(), 200));
    }
    const element2 = ref && ref.current ? ref : values.ref;
    const updateScrollValues = createScrollUpdater(
      values,
      getElementScrollOffsets(element2)
    );
    const scrollListener = addDomEvent(
      element2,
      "scroll",
      updateScrollValues,
      { passive: true }
    );
    const resizeListener = addDomEvent(
      element2,
      "resize",
      updateScrollValues
    );
    return () => {
      scrollListener && scrollListener();
      resizeListener && resizeListener();
    };
  };
  Object.assign(values, createScrollMotionValues(setScroll));
  return values;
};

// node_modules/svelte-motion/src/value/scroll/use-viewport-scroll.js
var viewportScrollValues;
function getViewportScrollOffsets() {
  return {
    xOffset: window.pageXOffset,
    yOffset: window.pageYOffset,
    xMaxOffset: document.body.clientWidth - window.innerWidth,
    yMaxOffset: document.body.clientHeight - window.innerHeight
  };
}
var hasListeners = false;
function addEventListeners() {
  hasListeners = true;
  if (typeof window === "undefined") return;
  const updateScrollValues = createScrollUpdater(
    viewportScrollValues,
    getViewportScrollOffsets
  );
  addDomEvent(window, "scroll", updateScrollValues, { passive: true });
  addDomEvent(window, "resize", updateScrollValues);
}
function useViewportScroll() {
  if (!viewportScrollValues) {
    viewportScrollValues = createScrollMotionValues();
  }
  tick().then((_) => {
    !hasListeners && addEventListeners();
  });
  return viewportScrollValues;
}

// node_modules/svelte-motion/src/utils/use-reduced-motion.js
var prefersReducedMotion;
function initPrefersReducedMotion() {
  prefersReducedMotion = motionValue(null);
  if (typeof window === "undefined") return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia(
      "(prefers-reduced-motion)"
    );
    const setReducedMotionPreferences = () => prefersReducedMotion.set(motionMediaQuery.matches);
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.set(false);
  }
}
var useReducedMotion = () => {
  !prefersReducedMotion && initPrefersReducedMotion();
  return derived(prefersReducedMotion, ($v) => $v);
};

// node_modules/svelte-motion/src/animation/UseAnimation.svelte
mark_module_start();
UseAnimation[FILENAME] = "node_modules/svelte-motion/src/animation/UseAnimation.svelte";
function UseAnimation($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UseAnimation);
  let controls = animationControls();
  onMount(controls.mount);
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", { controls }, null);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UseAnimation = hmr(UseAnimation, () => UseAnimation[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UseAnimation[HMR].source;
    set(UseAnimation[HMR].source, module.default[HMR].original);
  });
}
var UseAnimation_default = UseAnimation;
mark_module_end(UseAnimation);

// node_modules/svelte-motion/src/animation/use-animation.js
var useAnimation = () => {
  const controls = animationControls(() => {
    const cleanup = {};
    tick().then((v) => cleanup.clean = controls.mount());
    return () => {
      var _a;
      (_a = cleanup.clean) == null ? void 0 : _a.call(cleanup);
    };
  });
  return controls;
};

// node_modules/svelte-motion/src/utils/use-cycle.js
import { wrap } from "popmotion";
var useCycle = (...items) => {
  let index = 0;
  const x = writable(items[index]);
  const next = (i) => {
    index = typeof i !== "number" ? wrap(0, items.length, index + 1) : i;
    x.set(items[index]);
  };
  x.next = next;
  return x;
};

// node_modules/svelte-motion/src/gestures/drag/use-drag-controls.js
var DragControls = (
  /** @class */
  function() {
    function DragControls2() {
      this.componentControls = /* @__PURE__ */ new Set();
    }
    DragControls2.prototype.subscribe = function(controls) {
      var _this = this;
      this.componentControls.add(controls);
      return function() {
        return _this.componentControls.delete(controls);
      };
    };
    DragControls2.prototype.start = function(event, options) {
      this.componentControls.forEach(function(controls) {
        controls.start(event.nativeEvent || event, options);
      });
    };
    DragControls2.prototype.updateConstraints = function() {
      this.componentControls.forEach(function(controls) {
        controls.prepareBoundingBox();
        controls.resolveDragConstraints();
      });
    };
    return DragControls2;
  }()
);
var createDragControls = function() {
  return new DragControls();
};
var useDragControls = createDragControls;

// node_modules/svelte-motion/src/value/use-velocity.js
var useVelocity = (value) => {
  let val = value;
  let cleanup;
  const velocity = motionValue(value.getVelocity(), () => {
    cleanup == null ? void 0 : cleanup();
    cleanup = val.velocityUpdateSubscribers.add((newVelocity) => {
      velocity.set(newVelocity);
    });
    return () => {
      cleanup == null ? void 0 : cleanup();
    };
  });
  const reset2 = (valu) => {
    cleanup == null ? void 0 : cleanup();
    val = valu;
    cleanup = val.velocityUpdateSubscribers.add((newVelocity) => {
      velocity.set(newVelocity);
    });
  };
  velocity.reset = reset2;
  return velocity;
};

// node_modules/svelte-motion/src/components/MotionDiv.svelte
mark_module_start();
MotionDiv[FILENAME] = "node_modules/svelte-motion/src/components/MotionDiv.svelte";
var root_1 = add_locations(template(`<div><!></div>`), MotionDiv[FILENAME], [[7, 1]]);
function MotionDiv($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["div"]);
  push($$props, false, MotionDiv);
  let div = prop($$props, "div", 24, () => ({}));
  var fragment = comment();
  var node = first_child(fragment);
  MotionSSR_default(node, spread_props(() => $$restProps, {
    children: invalid_default_snippet,
    $$slots: {
      default: ($$anchor2, $$slotProps) => {
        const m = derived_safe_equal(() => $$slotProps.motion);
        const props = derived_safe_equal(() => $$slotProps.props);
        var div_1 = root_1();
        let attributes;
        var node_1 = child(div_1);
        slot(node_1, $$props, "default", {}, null);
        reset(div_1);
        action(div_1, ($$node) => {
          var _a;
          return (_a = get(m)) == null ? void 0 : _a($$node);
        });
        template_effect(() => attributes = set_attributes(div_1, attributes, { ...get(props), ...div() }));
        append($$anchor2, div_1);
      }
    }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MotionDiv = hmr(MotionDiv, () => MotionDiv[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MotionDiv[HMR].source;
    set(MotionDiv[HMR].source, module.default[HMR].original);
  });
}
var MotionDiv_default = MotionDiv;
mark_module_end(MotionDiv);
export {
  AnimatePresence_default as AnimatePresence,
  AnimateSharedLayout_default as AnimateSharedLayout,
  DragControls,
  FramerTreeLayoutContext,
  LayoutGroupContext,
  M2 as M,
  MotionDiv_default as Mdiv,
  motion as Motion,
  MotionConfig_default as MotionConfig,
  MotionConfigContext,
  MotionDiv_default as MotionDiv,
  MotionSSR_default as MotionSSR,
  MotionValue,
  PresenceContext,
  SharedLayoutContext,
  UseAnimation_default as UseAnimation,
  UseDomEvent_default as UseDomEvent,
  UseGestures_default as UseGestures,
  UsePanGesture_default as UsePanGesture,
  UseTapGesture_default as UseTapGesture,
  VisibilityAction2 as VisibilityAction,
  addScaleCorrection,
  animate2 as animate,
  animateVisualElement,
  animationControls,
  createBatcher,
  createCrossfader,
  createMotionComponent,
  isValidMotionProp,
  motionValue,
  resolveMotionValue,
  transform,
  useAnimation,
  useCycle,
  useDragControls,
  useElementScroll,
  useIsPresent,
  useMotionTemplate,
  motionValue as useMotionValue,
  usePresence,
  useReducedMotion,
  useSpring,
  useTransform,
  useVelocity,
  useViewportScroll,
  visualElement
};
//# sourceMappingURL=svelte-motion.js.map
